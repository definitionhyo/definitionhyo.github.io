---
layout: single
title:  "Java"
# 사이드바 추가 0705
categories:
  - programminglanguage
---

# Variable(변수)

* <span style="color:#ffdce0"> 반드시</span> 변수를 선언 후에 저장 가능
* 변수의 초기화 : 데이터를 저장하는 작업
* 변수 초기화 작업 없이 변수 사용 불가
* 하나의 데이터만 저장 가능
* 새로운 데이터를 저장하면 기존 데이터 제거  
  
             <변수 선언 기본 문법>   
               데이터타입 변수명;    
  
             <변수 선언 기본 문법>   
               데이터타입 변수명;   

            <변수 선언 및 초기화를 동시에 수행>
               데이터타입 변수명 = 데이터;
<br>
<hr>


# Data Type
<table border="1">
    <tr>
        <th>　　　</th>
        <th>1Byte(8bit)</th>
        <th>2Byte(16bit)</th>
        <th>4Byte(32bit)</th>
        <th>8Byte(64bit)</th>
    </tr>
    <tr text-align="center">
        <th>논리형</th>
        <td>boolean</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <th>정수형</th>
        <td>byte</td>
        <td>short</td>
        <td>int</td>
        <td>long</td>
    </tr>
    <tr>
        <th>실수형</th>
        <td></td>
        <td></td>
        <td>float</td>
        <td>double</td>
    </tr>    
    <tr>
        <th>문자형</th>
        <td></td>
        <td>char</td>
        <td></td>
        <td></td>
    </tr>    
</table>
<br>
<hr>

# 정수형 데이터타입 표현 범위
* byte(1Byte = 8bit) : 2^8 = 256가지 = -128 ~ +127
* short(2Byte = 16bit) : 2^16 = 65536가지 = -32768 ~ +32767
* int(4Byte = 32bit) : 2^32 = 약 -21억 ~ +21억 => 정수의 기본형  
* long(8Byte = 64bit) : 2^64 = 약 -922경 ~+922경  
<br>
<hr>

# 문자형 데이터타입 : char
* 내부적으로 정수형 데이터로 처리됨
* 2Byte(16bit) 크기의 범위 : 0 ~ 65535 사이의 값을 가짐<br>(음수X)
* 문자 표현 시 1개 문자를 '' 로 둘러싸서 표현<br> 
=> '' 내의 문자1개가 정수형으로 변환되어 처리됨<br>
ex) 'A' = 정수 65
* Unicode : 전 세계 문자를 표현하기 위한 체계 <br>
=> 아스키코드를 기반으로 나머지 문자를 추가하여 만든 코드 체계
아스키코드(ASCII, 7bit) : 미국 표준 문자 코드<br>
'A' = 65, 'a' = 97, '0' = 48<br>
=> 10진수로 된 코드갑을 사용하지만, 입력 시 16진수 코드 4자리 사용<br>
'\\' 기호와 'u'를 쓰고 16진수 XXXX 형태의 유니코드 값 표현 방법 사용  
<br>
<hr>

# 문자열 데이터 타입 : String
* ### 참조데이터타입 O (메모리크기가 모두 4Byte) <br>
기본데이터타입 X
* ### 0개 이상의 문자열 "" 로 둘러싸서 표현<br>
  => 아무 문자도 포함하지 않는 "" 문자열 = 널스트링(null string) 
<br>
<hr>

> JAVA0224
# 형변환(타입 변환)
* ### 자바 데이터타입 크기 관계  
  byte < short < int < long < float < double   
(  char  )  
* ### 자동(= 묵시적 = 암시적) 형변환
  * 작은 데이터타입 -> 큰 데이터타입  
* ### 강제(= 명시적) 형변환
  * 큰 데이터타입 -> 작은 데이터타입  
  * 우변의 데이터 앞에 '형변환 연산자'를 사용
  * Overflow(넘침) : 강제 형변환으로 오류가 없어지더라도 형변환 후의 데이터는 원본 데이터와 다를 수 있음  
* ### char 타입과 byte or short 강제형변환 필수  
 <br>
 <hr>

# Operator
* % 연산자 : 나머지(퍼센트) 연산자, 나눗셈 결과에 대한 나머지를 계산
* / 연산자 : 나숫셈 결과에 대한 몫을 계산
* 산술 연산 시 자동 형변환
  * int 보다 작은 타입 byte, short, char => 모두 int 타입으로 변환 후 연산을 수행
  * int 보다 큰 타입 long, float => 큰 타입으로 변환 후 수행
> JAVA0227
* ### 문자열 + 데이터 => 문자열 + 문자열 
* ### 대입 연산자(=)
  * 우변의 데이터를 좌변의 변수에 대입(저장)
* ### 비교(관계) 연산자 (>, >=, <, <=, ==, !=)
  * true 또는 false 리턴
  * double 과 float 비교시 실수 근사치 표현에 의해 잘못된 연산결과가 발생할 수 있음
* ### 논리 연산자 (&&, ||, !, ^)
  * boolean 타입만 사용 가능, 결과값도 boolean 타입 리턴
* ### AND 연산자(& or &&) - 논리곱
  * 두 피연산자 모두 true => true
  * &는 앞의 조건식이 false 여도 뒤의 조건식을 판별
* ### OR 연산자(| or ||) - 논리합
  * 두 피연산자 중 하나라도 true => true
  * |는 앞의 조건식이 true 여도 뒤의 조건식 판별
* ### NOT 연산자(!) - 논리부정
  * 현재 boolean 값을 반전
* ### XOR 연산자(^) - 배타적 논리합(exlusive OR)
  * 두 피연산자가 다를 경우 결과값이 true
* ### 삼항연산자(조건연산자) ( ?  :  )  
      < 기본 문법 >
      조건식 ? 값1(true) : 값2(false)

>JAVA0228
# 조건문
* ## if문
  * ### 단일(if문)  
  * ### if ~ else 문  
  * ### 다중 if ~ else if문  
    * 위에서 아래로 차례대로 수행 => 비교 범위가 좁은 조건식부터 해야함
  * ### 중첩 if 문  
<br>

* ## switch문(switch ~ case문)
  * if문과 달리 범위에 대한 판별등이 불가하고 값에대한 동등비교만 가능
  * 조건식에는 연산식 or 변수 or 리터럴 가능하지만  반드시 정수(byte, short, char, int) or 문자열(or enum 타입 상수)  
<br>

        < 기본 문법>
        switch(조건식) {
          case 값1:
            [break;] [] : 생략가능
          case 값2:
            [break;]
          case 값n:
            [break;]
          [default : ]
        }
  * case의 값을 여러개 지정할 때 case1: case2: 방식
      
# 반복문  
* ## for문
  * ### 반복 횟수가 정해져 있는 경우에 주로 사용  
   
```
<기본 문법 >
   for(초기식; 조건식; 증감식) {
      true 일때 반복 실행
        } 
```  

  * ## 중첩 for문
      * 안쪽 for문 반복횟수 = 안쪽 for문 횟수 * 바깥쪽 for문 횟수  
```

< 기본 문법> 
for(초기식1; 조건식1; 증감식1) {
  조건식1 true 일때 실행
  for(초기식2; 조건식2; 증감식2) {
    조건식2 true 일때 실행
  }
}

```  
>JAVA0308
* ## while문
  * for문과 달리 조건식 위치만 정해져있고 초기식, 증감식의 위치는 유동적(생략도 가능)
  * 주로 반복횟수가 정해져 있지 않은 경우 사용
  * for문과 100% 상호 변환 가능
```
while(조건식) {
  [증감식;]
  조건식 true 일때 반복 실행
  [증감식;]
}
```
* ## do ~ while문
  * 조건을 먼저 검사하고 반복여부를 결정하는 while문과 다르게 반복문을 실행 후 조건을 검사하여 반복여부를 결정 => 최소 한번은 실행됨
  * while문 뒤에 반드시 <span style="color:RED">세미콜론(;) 필수</span>
   
```
do {
  반복 실행
} while(조건식); 
```
  
* ## 중첩 while문
  * while문 내부에 while문 기술
   
```
초기식1;
while(조건식1) {
  초기식2;
  while(조건식2) {
    반복 실행
    증감식2;
  }
    증감식1;
}
```

# break_continue
  * ## break문 과 continue
    * 반복문 내에서 특정 조건식과 결합하여 반복문의 실행 흐름을 제어하는 용도로 사용
  * ## break문
    * 반복문을 종료하는 용도  
      주로 if문과 조합  

```  
for(초기식; 조건식; 증감식) or while(조건식) {
  if(조건){
    break;
  }
}
```  

  * ## continue문 
    * 반복문 내에서 조건에 따라 반복문의 다음 문장 실행을 생략하고 다음 반복을 진행하는 용도로 사용
     
```
for(초기식; 조건식; 증감식) or while(조건식) {
  if(조건) {
    continue;
    현재 반복문의 continue 문 아래쪽 문장 실행을  
    생략하고 다음 반복 실행을 위해 for문의 증감식 
    또는 while 문의 조건식으로 이동
  }
  문장; continue문에 의해 실행이 생략되는 문장
}
```
* ## Label 기능
  * 반복문의 앞에 위치하며 break or continue의 동작 지점을 지정
  * break문 or continue문 뒤 Label 지정할 경우 Label 위치의 다음 반복문에 break or continue문이 적용됨
  * 주로 중첩 반복문에서 반복문을 한꺼번에 빠져나가기 위해 사용함
  * 반복문 앞 또는 위에 주로 대문자로 된 문자를 작성하고 콜론을 붙임

# Method
* 동작(작업)의 최소 단위(= 작업을 수행하는 코드들의 모음)
* 메서드는 반드시 호출되어야만 실행될 수 있음
* 전달인자(Argument) : 메서드에 전달하는 값
* 매개변수(Parameter) : 전달인자를 전달받아 저장하는 변수 => 파라미터는 있을수도, 없을수도 있음
* 호출되면 작업을 수행 후 반드시 호출한 위치로 돌아감 => 호출한 곳으로 전달하는 값 : 리턴값(Return Value)
* 리턴타입을 명시한 메서드는 반드시 return문 사용하여 데이터를 리턴
  * 단, 리턴타입이 void인 메서드는 return 생략해도되고, 리턴값 없이 return문만 기술가능
  * 메서드 내에서 return문 만나면 즉시 메서드 종료후 돌아감
  * if 문 등의 조건식을 사용할 경우 반드시 어떤 경우에도 return 문이 실행되도록 조건식을 작성해야함 
* main() 메서드 : 자바에서 유일하게 호출하지 않아도 프로그램 실행 시점에서 자동으로 호출되는 메서드
  * 자바 프로그램의 시작점(Starting point)
  * 호출 시 매개변수와 일치하는 타입 및 개수의 데이터를 전달해야함
   
```
< 메서드 정의 기본 문법 >
[접근제한자] 리턴타입 메서드명([매개변수선언...]) {
  메서드 호출 시 수행할 코드
  [return [리턴값];]
}
```

```
< 메서드 호출 기본 문법>
1. 리턴값 X
  메서드명([데이터...]);

2.리턴값 O
  1) 데이터 타입 변수 = 메서드명([데이터...]); => 리턴되는 데이터를 변수에 저장할 경우
  2) System.out.println(메서드명([데이터...])); => 리턴되는 데이터를 출력하거나 직접 연산에 사용하는 경우
```

< 메서드 형태 4가지 >
1. 파라미터 X 리턴값 X  
2. 파라미터 X 리턴값 O
3. 파라미터 O 리턴값 X
4. 파라미터 O 리턴값 O

* 메서드 호출 방법  
=> 전달할 데이터가 있을 경우 () 안에 데이터를 명시(복수인 경우 ,로 구분)

```
* < 메서드 정의 기본 문법 >
[접근제한자] 리턴타입 메서드명([매개변수선언...]) {
  호출 시 수행할 코드
  [return [리턴값];]
}
```

> JAVA0314
# Class
* main() 메서드에서부터 객체를 생성하고 사용가능 단, main()메서드가 호출하는 다른 메서드에서도 사용 O
* 클래스의 실제 사용을 위해서는 반드시 실체(=객체)를 생성해야 함
* 인스턴스(Instance) : 클래스를 사용하여 메모리에 생성된 객체(실체)
 
```
< 클래스에 대한 인스턴스 생성 기본 문법 >
클래스명 변수명 = new 클래스명();
```

```
< 인스턴스 접근 기본 문법(멤버변수 접근 및 메서드 호출) >
참조변수명.멤버변수 or 참조변수명.메서드()
```

*  하나의 java 파일 내에 여러개의 클래스 정의 가능 But 파일명과 동일한 클래스 외에는 public 키워드 사용 X
>JAVA0315
# Access_modifier
* ### 접근제한자
  * 클래스, 메서드, 멤버변수 등의 접근 제한 용도로 사용하는 키워드
  * (넓은) public > protected > default > private (좁음)   
   => 단, default 접근제한자 별도의 키워드 없이 생략하면 적용
  ### 1. private 접근제한자
  * 외부 클래스에서 접근 X 자신의 클래스 내에서만 접근 O
  * 주로 외부에서 접근 못하게 멤버변수에 적용
  * Getter/Setter 메서드를 통해 멤버변수 값을 변경 or 리턴
  <details>
  <summary>Getter / Setter</summary>
  
  * 메서드 자동 생성 단축키  
    => Alt + Shift + S -> R
  * Getter : 내부 멤버변수 값을 외부로 리턴하는 메서드 => getXXX()
  * Setter : 외부로부터 값을 받아 내부 멤버변수에 저장하는 메서드 => setXXX()
  </details>  
  
# Constructor
* ### 생성자
  * 클래스를 사용하여 인스턴스를 생성할 때 호출되는 메서드 형태  
    => new 키워드 뒤에 생성자 호출 코드 
    기술
  * 주로 인스턴스 변수를 초기화 or 인스턴스 생성 시 초기에 수행할 작업을 기술
  * 메서드의 형태와 유사하나 차이점 2가지 존재
    1. 선언부에 리턴타입 존재 X(리턴값이 없는게 아니라 리턴타입 자체를 기술 X)
    2. 생성자 이름이 클래스 이름과 동일
   * 클래스 정의 시 생성자를 하나도 정의 X -> 컴파일러에 의해 자동으로 기본(Default) 생성자 생성
   * 메서드와 유사한 형태이므로 파라미터가 O or X
   * 생성자 별도로 호출 불가, 반드시 new 키워드 뒤에만 지정 가능
    
  ```
  < 생성자 정의 기본 문법 >
  [접근제한자] 클래스명([매개변수선언...]) {
    생성자 호출 시점(인스턴스 생성 시점) 수행할 작업
    인스턴스 변수 초기화 등
  }
  ```
  
  ```
  < 인스턴스 생성 기본 문법 >
  클래스명 참조변수명 = new 생성자명([데이터...]);
  ```

 * 파라미터 생성자 
   * 생성자 호출 시 데이터를 전달 해야할 경우 생성자 파라미터(매개변수) 선언 가능(메서드와 동일)
   * 전달받은 데이터는 인스턴스 변수를 초기화 하는 용도로 사용  
   => 객체마다 다른 데이터를 가진 인스턴스를 생성하기 위해 사용

   ```
   < 파라미터 생성자 정의 기본 문법 >
   [접근제한자] 클래스명(매개변수 ...) {
    인스턴스변수명 = 데이터; => 파라미터에 데이터를 전달해 인스턴스 내의 인스턴스 변수 초기화
   }
   ```

    * 파라미터 생성자 단축키 : Alt + Shift + S -> O (멤버변수가 하나도 없을 경우 실행안됨) 
<br>
<br>
>JAVA0316
# Array
* ### 배열
  * 같은 타입 데이터만 저장 가능
  * 한번 생성된 배열은 크기 변경 불가
  * 기본, 참조 데이터타입 모두 배열 가능
  * 선언 -> 생성 -> 초기화
  * 인덱스(번호) 0부터시작 => 배열크기 -1 까지 부여됨
  * 배열의 데이터 저장 공간은 배열의 데이터타입의 기본값으로 자동 초기화  
  => byte, short, int = 0, long = 0L, float = 0.0f, double = 0.0
  char = 0 또는 '\u0000', boolean =  false, String = null  
  * 배열 크기 = 배열명.length  

  ```
  < 배열 선언 기본 문법 >
  데이터타입[] 변수명;
  ```
  => 배열 공간 생성전 이므로 데이터 지정 불가  
  => 선언된 배열의변수 = 참조형 변수로 취급(int : 기본형 | int[] : 참조형)
    
  ```
  < 배열 생성 기본 문법 >
  변수명 = new 데이터타입[배열크기];
  ```
  => new 키워드를 사용하여 배열 공간을 생성하는데 데이터타입 뒤의 대괄호 안에 생성할 배열의 크기를 명시
  => 생성되는 배열의 위치(주소값)을 선언된 배열 타입 변수에 저장
  => 실제 메모리 공간이 생성되었으므로 데이터 저장 가능
  => 생성된 배열에는 자동으로 인덱스 번호가 부여됨(인덱스번호는 0 ~ 배열크기 -1 까지 자동으로 부여됨)

  ```
  < 배열 선언 및 생성을 하나의 문장으로 결합 >
  데이터타입[] 변수명 = new 데이터타입[배열크기];
  ```

  ```
  < 배열 접근 기본 문법 >
  변수명[인덱스]
  => 변수명에 해당하는 주소(배열 공간)에 접근 한 뒤 
     인덱스에 해당하는 데이터 저장 공간에 접근
  => 배열에 데이터 초기화(저장) 
     변수명[인덱스] = 데이터;
  ```  

  ```
  < 반복문을 통해서 배열의 모든 인덱스 접근 기본 공식 >
  for(int i = 0; i < 배열명.length; i++) {
    // 배열명[i] 형태로 접근
  }
  ```

  ```
  < 배열 선언, 생성, 초기화를 한꺼번에 수행하는 문법 >
  데이터타입[] 변수명 = {데이터1, 데이터2, ... 데이터n};
  => 배열 생성 문법을 별도로 명시하지 않고
     중괄호를 사용하여 초기화할 데이터를 리터럴 형태로 전달하면
     해당 데이터 개수만큼 배열 공간이 자동으로 생성됨
  => n개 만큼의 공간을 생성하면서 인덱스번호가 0 ~ n-1 까지 부여되고
     자동으로 기본값으로 초기화됨
  ```

* ### 2차원 배열
   * 1차원 배열 여러개의 묶음을 관리하는 배열
  * 행과 열로 이루어진 테이블(표) 구조와 유사한 구조의 배열
    <br>&nbsp;&nbsp; => 행과 열의 인덱스는 1차원 배열과 동일(0번부터 시작)

  ```
  < 2차원 배열 선언 및 생성 기본 문법 >
  데이터타입[][] 변수명 = new 데이터타입[행크기][열크기];
  ```

  ```
  < 2차원 배열 접근 기본 문법 >
  변수명[행인덱스][열인덱스];
  ```

  ```
  < 2차원 배열 선언, 생성, 초기화를 한꺼번에 수행하는 문법 >
  데이터타입[][] 변수명 = {
 	{값1, 값2, ..., 값n}, // 0행(0열, 1열, ..., n열)
    {값1, 값2, ..., 값n}, // 1행(0열, 1열, ..., n열)
    ... 생략 ...
    {값1, 값2, ..., 값n} // m행(0열, 1열, ..., n열)
  };
  ```

  < 2차원 배열 크기 >
  1. 행 크기 : 변수명.length
  2. 열 크기 : 변수명[행번호].length

  ```
  < 2차원 배열의 모든 요소를 차례대로 접근하는 문법 >
  for(int i = 0; i < 변수명.length; i++) { // 행 반복

    for(int j = 0; j < 변수명[i].length; j++ { // 열 반복
  	// 변수명[i][j] 로 배열 각 요소에 접근
    }

  }
  ```

  * 2차원 배열은 행을 먼저 생성한 후 별도로 열을 각각 생성 가능하다!
  <br> 데이터타입[][] 배열명 = new 데이터타입[행크기][];
  <br> int[][] arr2 = new int[3][]; // 3행의 공간이 먼저 생성됨
  <br> 각 행에 접근하여 열을 생성하는 코드를 작성
  <br> 배열명[행번호] = new int[열크기];
  * 각 행의 공간에 열 공간을 생성하면서 데이터 초기화까지 수행
  * 2차원 배열 선언 및 생성, 초기화까지 한꺼번에 수행
  ```
  int[][] arr2 = {
				{1, 2, 3},
				{1, 2},
				{1, 2, 3, 4}
		};
  ```

>JAVA0317
# Overloading
* ### 메서드 오버로딩(Method Overloading) = 메서드 다중 정의
  * 동일한 이름의 파라미터가 다른 메서드를 여러번 정의하는 것
  * 비슷한 기능을 수행하지만, 전달받은 데이터의 타입이 다른 경우 
  <br>메서드 이름을 각각 따로 정의하고 않고, 동일한 이름으로
  <br>파라미터만으로 구분되는 메서드를 여러개 정의하는 것
  * 주의사항! 메서드 시그니쳐(이름, 리턴타입, 파라미터, 접근제한자) 중
  <br>파라미터를 제외한 나머지는 동일하게 정의함
  <br>=>외부에서 메서드를 호출하는 시점에 이름이 동일한 메서드 간에
  <br>&nbsp;&nbsp;&nbsp;&nbsp; 전달되는 데이터(파라미터)만으로 각 메서드가 구분되어야 함

  * < 메서드 오버로딩 규칙(택 1) >
  <br>1. 메서드 파라미터의 데이터타입이 달라야 함
  <br>2. 메서드 파라미터의 개수가 달라야 함
  * 주의! 파라미터의 변수명만 다를 경우 오버로딩 성립되지 않음 => 오류 발생
  * 주의! 리턴타입만 다를 경우 오버로딩 성립되지 않음 => 오류 발생
  * 일반적으로 메서드명도 식별자에 해당하므로 중복이 불가능함
  <br>=> 메서드 정의 시 메서드명을 달리해야하므로 호출 시 구분이 불편할 수 있음

* ### 생성자 오버로딩
  * 메서드 오버로딩과 동일
  * 생성자 호출 시 다양한 형태의 파라미터를 전달하여 객체를 다양하게 초기화 하는 목적
  * 파라미터 생성자를 하나라도 정의할 경우
  * 컴파일러에 의해 기본 생성자가 자동으로 생성되지 않는다.
  * 따라서, <b>기본 생성자를 호출해야 하는 경우 직접 기본 생성자를 정의</b>!

* ### 메서드 오버로딩 문제점
  * 동일한 작업을 수행하는 코드들의 중복이 발생
  <br>=> 만약, 특정 메서드의 코드를 수정해야할 경우 동일한 코드를 여러번 수정해야하는 번거로움이 발생할 수 있음!
  <br>=> 코드의 유지보수성이 나쁘다!

  * 해결책
    * 오버로딩 된 메서드에서 또 다른 오버로딩 된 메서드를 호출하여 중복되는 작업을 대신 처리하도록 할 수 있다!
    <br>=> 메서드 호출 시 자신의 전달받은 파라미터를 다시 전달
    <br>=> 이처럼 클래스 내의 다른 메서드를 호출하여 사용 = 코드의 재사용

* ### 가변형 인자 = 비정형 인자(Variable Arguments, VARARSS)
  * 메서드 파라미터를 하나의 인자만 사용하여 다양하게 전달받는 기능
  * 동일한 타입의 파라미터를 0개 ~ 무한대로 전달받아 배열로 관리
  <br> => 전달받는 인자(데이터)의 개수에 따라 자동으로 배열 생성됨
  * 메서드 파라미터(매개변수) 선언 시 데이터타입 뒤에 ... 기호를 표기
  <br> ex) public void add(int... nums) {}
  * 가변 인자를 사용한 메서드 대표적인 예 : printf() 메서드
  <br> => System.out.printf(String str, Object... objs) {}
  * 다른 파라미터와 가변 인자를 조합 가능
  * 주의! 가변 인자는 마지막 파라미터로 단 한 번만 지정 가능!
  *   가변 인자를 사용한 메서드 오버로딩
  <br> => 메서드 정의 시 파라미터로 사용할 변수 데이터타입 뒤에 ... 기호 붙임
      ```
      public void print(String... names) {
        // String 타입 데이터를 0 ~ 무한대로 전달받을 수 있으며
        // 전달된 데이터는 자동으로 배열 생성 후 저장됨
        // => 가변인자를 사용한 변수 names 는 String[] 타입으로 사용됨
        //    따라서, 배열 접근 방법을 활용하여 배열 내의 모든 요소에 접근
        // for문을 사용하여 배열 내의 모든 데이터 출력
        for(int i = 0; i < names.length; i++) {
          System.out.print(names[i] + " ");
        }
        System.out.println();
      }
      ```

  * 다른 파라미터와 가변 인자 조합 가능
      ```
      public void print2(int num, String... names) {
        // => int형 데이터 1개와 문자열 데이터 여러개를 전달 가능
        // ex) print2(2, "홍길동", "이순신");
      }
      ```
  * 가변 인자는 다른 파타미터 앞에 올 수 없음
  * 가변 인자가 2개 이상 올 수 없음
<br>
<br>
>JAVA0320
# pass_by
  * 메서드 호출 시 값 전달 방식에 따른 차이
  <br> = 메서드 파라미터로 기본 데이터타입과 참조 데이터타입 전달 시 차이
  <br> => 메서드 호출 시 값을 전달할 경우 값의 복사가 일어남
  * 1.Pass by value(값에 의한 전달)
  <br> - 메서드 호출 시 기본 데이터타입 데이터 전달하는 경우
  => 실제 값(실제 데이터)을 복사해서 전달
  <br> - 호출된 메서드 내에서 전달받은 값(복사한 데이터)을 변경해도 원본 데이터에는 아무런 영향이 없음
  * 2.Pass by reference(참조에 의한 전달)
  <br> -메서드 호출 시 참조 데이터타입 데이터 전달하는 경우
  <br> => 실제 값이 있는 공간의 주소 값(참조 값)을 복사해서 전달
  <br> - 호출된 메서드 내에서 전달받은 값(복사한 주소값)을 접근하여 해당 주소에 있는 데이터를 변경하는 경우 원본 데이터도 동일한 주소값을 참조하므로 변경된 결과에 영향을 받음

# this
  * 자신의 인스턴스 주소값을 저장하는 참조 변수
  <br> => 개발자가 생성하는 것이 아니라 자바에 의해 자동으로 생성됨
  * 모든 인스턴스 내에는 this 가 존재하며, 자신의 인스턴스 주소가 저장
  <br> => 인스턴스마다 this 에 저장된 값이 서로 다름
  1. 레퍼런스 this
  <br> - 자신의 인스턴스 내의 멤버에 접근(멤버변수 or 멤버메서드)
  <br> - 주로, 로컬변수와 인스턴스(멤버)변수의 이름이 같을 때 인스턴스 변수를 지정하는 용도로 사용
      ```
      < 레퍼런스 this 사용 기본 문법 >
      자신의 클래스 내의 생성자 또는 메서드 내에서 
      this.인스턴스 변수 또는 this.메서드() 형태로 접근
      ```
  2. 생성자 this()
  <br> - 자신의 생성자 내에서 자신의 또 다른 생성자를 호출
  <br> - 레퍼런스 this 사용과 동일하게 자신의 인스턴스에 접근하여
  <br> &nbsp;&nbsp; 다른 오버로딩 생성자를 호출하는 용도로 사용
  <br> - 생성자 오버로딩 시 인스턴스 변수에 대한 초기화 코드가 중복되는데 
  <br> &nbsp;&nbsp; 초기화 코드 중복을 제거하는 용도로 사용
  <br> &nbsp;&nbsp; => 여러 생성자에서 각각 인스턴스 변수를 중복으로 초기화 하지 않고 
  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 하나의 생성자에서만 초기화 코드를 작성한 뒤 
  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 나머지 생성자에서는 해당 초기화 코드를 갖는 생성자를 호출하여
  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 초기화 할 값만 전달 후 대신 인스턴스 변수 초기화를 수행함
  <br> &nbsp;&nbsp; => 메서드 오버로딩 시 코드 중복을 제거하기 위해서 
  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 하나의 메서드에서만 작업을 수행하고 나머지 메서드는 
  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 해당 메서드를 호출하여 데이터를 전달하는 것과 동일함
  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (단, 메서드 이름()으로 호출, 생성자는 this() 로 호출하는 차이)
      ```
      < 생성자 this() 호출 기본 문법 >
      생성자 내의 첫번째 라인에서
      this([데이터...]);
      ```