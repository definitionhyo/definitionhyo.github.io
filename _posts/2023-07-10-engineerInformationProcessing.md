---
layout: single
title:  "정보처리기사 실기(시나공)"
categories:
  - sundry
published : false
---

# 1-1 요구사항 확인 1 
### 중요도 <span style="color:red">A</span><br>

<details>
  <summary></summary>
  <div markdown="1">

  * 애자일 모형 : 고객의 <b>요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형</b>
  * 고객과의 소통에 초점을 맞춘 방법론을 통칭
  * 대표적인 개발모형 
    * 스크럼
    * XP(eXtreme Programming)
    * 칸반
    * Lean
    * 기능 중심 개발(FDD)

* 애자일 개발 4가지 핵심 가치
  * 프로세스와 도구 < 개인과 상호작용
  * 방대한 문서 < 실행되는 SW
  * 계약 협상 < 고객과 협업
  * 계획에 따르는 것 < 변화에 반응하는 것

* Xp의 주요 실천 방법(Practice)
  * <b>Pair Programming(짝 프로그래밍)</b>
    <br>- 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠갖는 환경을 조성

  * <b>Collective OwnerShip(공동 코드 소유)</b>
    <br>- 개발 코드에 대한 권한과 책임을 공동으로 소유

  * <b>Test-Driven Development(테스트 주도 개발)</b>
    <br>- 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악
    <br>- 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용

  * <b>Whole Team(전체 팀)</b>
    <br>- 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함

  * <b>Continuous Integration(계속적인 통합)</b>
    <br>- 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합됨

  * <b>Refactoring(리팩토링)</b>
    <br>- 프로그램 기능의 변경 없이 시스템을 재구성
    <br>- <b>목적</b> : 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함 

  * <b>Small Releases(소규모 릴리즈)</b>
    <br>- 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응 가능

* 기능 요구사항
  <br> - 시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항
  * 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지에 대한 사항
  * 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
  * 시스템이 반드시 수행해야 하는 기능
  * 사용자가 시스템을 통해 제공받기를 원하는 기능

* 비기능 요구사항
  <br> - 품질이나 제약사항과 관련된 요구사항
  * 시스템 장비 구성 요구사항 
  * 성능 요구사항 
  * 인터페이스 요구사항 
  * 데이터를 구축하기 위해 필요한 요구사항 
  * 테스트 요구사항 
  * 보안 요구사항 
  * <b>품질 요구사항 : </b>가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성 등
  * 제약사항
  * 프로젝트 관리 요구사항 
  * 프로젝트 자원 요구사항 

* 자료 흐름도의 구성 요소<br>
  기호 | 의미 |
  ---------|--------|
  프로세스<br>(Process) | 자료를 변환시키는 시스템의 한 부분(처리과정)을 나타내며 처리, 기능, 변환, 버블이라고도 함 |
  자료 흐름<br>(Data Flow) | 자료의 이동(흐름)이나 연관관계를 나타냄 |
  자료 저장소<br>(Data Store) | 시스템에서의 자료 저장소(파일, 데이터베이스)를 나타냄 |
  단말<br>(Terminator) | 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력데이터를 받음 |

* 자료 사전
  <br> - <b>자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것</b>
  <br> - 데이터를 설명하는 데이터로 데이터의 데이터 또는 메타 데이터라고도 함
  <br> - <b>자료 사전에서 사용되는 표기 기호</b>
  기호 | 의미 |
  -----|------|
   = | <b>자료의 정의</b> : ~로 구성되어 있다(is composed of) |
   **+** | <b>자료의 연결</b> : 그리고(and) |
   () | <b>자료의 생략</b> : 생략 가능한 자료(Optional) |
   [] | <b>자료의 선택</b> : 또는(or) |
   {} | <b>자료의 반복</b> : Iteration of |
   ** | <b>자료의 설명</b> : 주석(Comment) |

* HIPO
  <br> - 시스템의 분석 및 설계, 또는 문서화에 사용되는 기법으로, <b>시스템 실행 과정인 입력·처리·출력의 기능을 표현한 것</b>
  <br> - 하향식 소프트웨어 개발을 위한 문서화 도구
  <br> - 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들간의 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 함

* UML
  <br> - <b>시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어</b>
  <br> - Rumbaugh, Booch, Jacobson 등의 객체지향 방법론의 장점을 통합함
  <br> - <b>UML의 구성 요소</b>
  <br> - 사물(Things)
  <br> - 관계(Relationships)  
  <br> - 다이어그램(Diagram)

* 집합 관계
  <br> - <b>하나의 사물이 다른 사물에 포함되어 있는 관계</b>
  <br> - 포함하는 쪽과 포함되는 쪽은 서로 독립적
  <br> - 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현

* 일반화 관계
  <br> - <b>하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계</b>
  <br> - 보다 일반적인 개념 = 상위(부모), 보다 구체적인 개념 = 하위(자식)
  <br> - 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현
  
* 의존 관계
  <br> - 연관 관계와 같이 사물 사이에 연관은 있으나 필요에 의해 <b>서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계</b>
  <br> - 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계
  <br> - 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개 변수로 사용하는 경우에 나타나는 관계
  <br> - 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자)쪽으로 점선 화살표를 연결하여 표현

* 실체화 관계
  <br> - <b>사물이 할 수 있거나 해야하는 기능으로, 서로를 그룹화 할 수 있는 관계</b>
  <br> - 한 객체가 다른 객체에서 오퍼레이션을 수행하도록 지정하는 의미적 관계
  <br> - 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현
  </div>
</details>


### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
* 나선형 모형 : <b>여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로</b> 완벽한 최종 소프트 웨어를 <b>개발하는 모형</b>
  * 보헴이 제안
  * <b>4가지 주요 활동</b><br>
    계획수립 -> 위험분석 -> 개발 및 검증 -> 고객 평가

* 폭포수 모형 : <b>각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론</b>
  * 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트퉤어 생명 주기 모형
  * 고전적 생명 주기모형 이라고도 함

* 소프트웨어 공학 : <b>소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문</b>

* XP : <b>요구사항에 유연하게 대응하기 위해 고객의 참여와 개발과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법</b>
  * 5가지 핵심 가치 : 의단용존피
    * 의사소통(Communication)
    * 단순성(Simplicity)
    * 용기(Courage)
    * 존중(Respect)
    * 피드백(Feedback)
  
* 데이터베이스 관리 시스템(DBMS) : <b>사용자와 데이터베이스 사이에서</b> 사용자의 요구에 따라 <b>정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어</b>
  * DBMS 관련 요구사항 식별 시 고려사항 : 가성기상구
   <br> - 가용성
   <br> - 성능
   <br> - 기술 지원
   <br> - 상호 호환성
   <br> - 구축 비용

* 요구사항 개발 프로세스
  * 개발 대상에 대한 요구사항을 체계적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활동
  * 요구사항 개발 프로세스가 진행되기 전에 타당성 조사가 선행되어야 함
  * 요구사항 개발은 요구공학의 한 요소이다
  * <b>도출</b> -> <b>분석</b> -> <b>명세</b> -> <b>확인</b> 

* 요구사항 명세 기법<br>
  구분 | 정형 명세 기법 | 비정형 명세 기법 |
  ---------|----------| ----------------|
  기법 | 수학적 원리 기반, 모델 기반 | 상태/기능/객체 중심 |
  작성<br>방법 | 수학적 기호, 정형화된 표기법 | 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성 |
  특징 | * 요구사항을 정확하고 간결하게 표현할 수 있음<br> * 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능함<br> * 표기법이 어려워 사용자가 이해하기 어려움 | * 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 있음<br> * 내용의 이해가 쉬어 의사소통이 용이함 |
  종류 | VDM, Z, Petri-net, CSP | FSM, Decision Table, ER모델링, State Chart(SADT) |

* 요구사항 분석
  <br> - 소프트웨어 개발의 실제적인 첫 단계, <b>개발 대상에 대한 사용자의 요구사항을 이해하고 문서화하는 활동</b>
  <br> - 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정
  <br> - 사용자의 요구를 정확하게 추출하여 목표를 정함

* 자료 흐름도
  <br> - 요구사항 분석에서 <b>자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법</b>
  <br> - 자료 흐름 그래프, 버블차트라고도 함
  <br> - 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용됨

* SADT
  <br> - <b>시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구</b>
  <br> - SoftTech 사에서 개발
  <br> - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구

* 구조적 다이어그램의 종류
  <br> * <b>클래스 다이어그램(Class Diagram)</b><span style="color:red"><small> * 필기 21.5, 21.3 20.6</small></span>
  <br>&nbsp; - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
  <br> * <b>객체 다이어그램(Object Diagram)</b><span style="color:red"><small> * 필기 20.6</small></span>
  <br>&nbsp; - 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현
  <br>&nbsp; - 럼바우 객체지향 분석 기법에서 객체 모델링에 활용
  <br> * <b>컴포넌트 다이어그램(Component Diagram)</b><span style="color:red"><small> * 필기 20.6</small></span>
  <br>&nbsp; - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
  <br>&nbsp; - 구현 단계에서 사용
  <br> * <b>배치 다이어그램(Deployment Diagram)</b>
  <br>&nbsp; - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
  <br>&nbsp; - 구현 단계에서 사용
  <br> * <b>복합체 구조 다이어그램(Composite Structure Diagram)</b>
  <br>&nbsp; - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현 
  <br> * <b>패키지 다이어그램(Package Diagram)</b>
  <br>&nbsp; - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현

* 행위 다이어그램의 종류
  <br> * <b>유스케이스 다이어그램(Use Case Diagram)</b><span style="color:red"><small> * 필기 20.8</small></span>
  <br>&nbsp; - 사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용
  <br>&nbsp; - 사용자(Actor)와 사용 사례(Use Case)로 구성
  <br> * <b>시퀀스 다이어그램(Sequence Diagram)</b><span style="color:red"><small> * 필기 21.5 21.3 20.8</small></span>
  <br>&nbsp; - 상호작용하는 시스템이나 객체들이 주고받는 메시지를 표현 
  <br> * <b>커뮤니케이션 다이어그램(Communication Diagram)</b>
  <br>&nbsp; - 동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현
  <br> * <b>상태 다이어그램(State Diagram)</b><span style="color:red"><small> * 필기 21.3 20.9</small></span>
  <br>&nbsp; - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지를 표현
  <br>&nbsp; - 럼바우 객체지향 분석 기법에서 동적 모델링에 활용
  <br> * <b>활동 다이어그램(Activity Diagram)</b><span style="color:red"><small> * 필기 21.5 20.8</small></span>
  <br>&nbsp; - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현
  <br> * <b>상호작용 개요 다이어그램</b>
  <br>&nbsp; - 상호작용 다이어그램 간의 제어 흐름을 표현
  <br> * <b>타이밍 다이어그램(Timing Diagram)</b>
  <br>&nbsp; - 객체 상태 변화와 시간 제약을 명시적으로 표현

* 스테레오 타입
  <br> - UML에서 표현하는 <b>기본 기능 외에 추가적인 기능을 표현하는 것</b>
  <br> - 길러멧(Guilemet)이라고 부르는 겹화살괄호(<< >>) 사이에 표현할 형태를 기술
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  * 소프트웨어 생명 주기
   <br> - <b>소프트웨어를 개발하기 위한 과정을 각 단계별로 나눈 것</b> 

  

  </div>
</details>


<br>


# 1-2 요구사항 확인 2 
### 중요도 <span style="color:red">A</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
* 유스케이스 다이어그램
  <br> - 사용자와 다른 외부 시스템들이 <b>개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것</b>
  <br> - 액터 
  <br>&nbsp;&nbsp;&nbsp; · 시스템과 상호작용을 하는 모든 외부 요소
  <br>&nbsp;&nbsp;&nbsp; · <b>주액터</b> : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당됨
  <br>&nbsp;&nbsp;&nbsp;&nbsp;· <b>부액터</b> : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있음
  <br> - 관계 <br>&nbsp;&nbsp;&nbsp; · <b>유스케이스에서 나타날 수 있는 관계</b> : 포함(include) 관계, 확창(Extends) 관계, 일반화(Generaliztion) 관계

  * 유스케이스에서 나타날 수 있는 관계
    * 포함(Include) 관계
      <br> - 두 개 이상의 유스케이스에 공통적으로 적용되는 기능을 별도로 분리하여 새로운 유스케이스로 만든 경우, 원래의 유스케이스와 새롭게 분리된 유스케이스와의 관계를 말함
      <br> - 원래의 유스케이스에서 새롭게 만든 포함되는 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 <<**include**>>라고 표기함 
    * 확장(Extend) 관계
      <br> - 유스케이스가 특정 조건에 부합되어 유스케이스 기능이 확장될 때 원래의 유스케이스와 확장된 유스케이스와의 관계를 말함
      <br> - 확장될 유스케이스에서 원래의 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 <<**extend**>> 라고 표기함

* 클래스 다이어그램
  <br> - <b>클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것</b>
  <br><b> * 클래스 다이어그램의 구성 요소</b>
  * 클래스<span style="color:red"><small> * 필기 21.10 21.8</small></span>
    <br> - 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현한 것
    <br> - <b>속성(Attribute)</b> : 클래스의 상태나 정보를 표현
    <br> - <b>오퍼레이션(Operation)</b> : 클래스가 수행할 수 있는 동작으로, 함수(메소드)라고도 함

* 커뮤니케이션 다이어그램
  <br> - <b>시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것</b>

* 상태 다이어그램
  <br> - <b>객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것</b>

* 패키지 다이어그램
  <br> - 유스케이스나 클래스 등의 <b>요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것</b>
  * 패키지 다이어그램의 구성요소
  <br> - <b>단순 표기법</b> : 패키지 안에 패키지 이름만 표현
  <br> - <b>확장 표기법</b> : 패키지 안에 요소까지 표현

* 소프트웨어 재사용
  <br> - <b>이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것</b>
  <br> * 소프트웨어 재사용 방법
  <br> &nbsp;&nbsp; - <b>합성 중심</b> : 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 함
  <br> &nbsp;&nbsp; - <b>생성 중심</b> : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법, 패턴 구성방법이라고도 함

* CASE
  <br> - <b>소프트웨어 개발 과정에서 사용되는</b> 요구 분석, 설계, 구현, 검사 및 디버깅 <b>과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것</b>

* LOC 기법(상향식 비용 산정 기법)
  <br> - 소프트웨어 <b>각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법</b>
  <br> - 개발에 소요되는 기간 =  (LOC(총 라인수) / 1인당 월평균 생산 코드 라인 수)

* COCOMO의 소프트웨어 개발 유형
  * <b>조직형(Organic Mode)</b><span style="color:red"><small> * 필기 21.8 21.5 21.3 20.8 20.6</small></span>
  <br> - 중·소 규모의 소프트웨어
  <br> - 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용 등의 5만(50KDSI) 라인 이하의 소프트웨어를 개발하는 유형
  * <b>반분리형(Semi-Detached Mode)</b><span style="color:red"><small> * 필기 21.5 21.3 20.8</small></span>
  <br> - 조직형과 내장형의 중간형 소프트웨어
  <br> - 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만(300KDSI) 라인 이하의 소프트웨어를 개발하는 유형
  * <b>내장형(Embedded Mode)</b><span style="color:red"><small> * 필기 21.5 21.3 20.8</small></span>
  <br> - 초대형 규모의 소프트웨어
  <br> - 트랜잭션 처리 시스템이나 운영체제 등의 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형

* ISO/IEC 12207 : <b>ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스</b>
  <br> - <b>기본 생명 주기 프로세스</b><span style="color:red"><small> * 필기 21.5</small></span>
  <br> &nbsp;&nbsp; : 획득, 공급, 개발, 운영, 유지보수 프로세스
  <br> - <b>지원 생명 주기 프로세스</b>
  <br> &nbsp;&nbsp; : 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상관리, 문제 해결 프로세스?
  <br> - <b>조직 생명 주기 프로세스</b>
  <br> &nbsp;&nbsp; : 관리, 기반 구조, 훈련, 개선 프로세스

* SPICE의 프로세스 수행 능력 단계(0~5 불수관확예최)
  <br> &nbsp;&nbsp; - 0 불완전 | 1 수행 | 2 관리 | 3 확립 | 4 예측 | 5 최적화
    </div>
</details>



### 중요도 <span style="color:#0000ff">B</span><br>

<details>
    <summary></summary>
    <div markdown="1">
    내용
* 시퀀스 다이어그램
  <br> - <b>시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정을 그림으로 표현한 것</b>
  * 시퀀스 다이어그램의 구성요소
   <br> - 액터(Actor)
   <br> - 객체(Object)
   <br> - 생명선(Lifeline)<span style="color:red"><small> * 필기 20.8</small></span>
   <br> - 실행 상자(Active Box, 활성 상자)<span style="color:red"><small> * 필기 20.8</small></span>
   <br> - 메시지(Message)<span style="color:red"><small> * 필기 20.8</small></span>
   <br> - 객체 소멸
   <br> - 프레임

* 구조적 방법론
  <br> - 정형화된 분석 절차에 따라 <b>사용자 요구사항을 파악하여 문서화하는 처리(Precess) 중심의 방법론</b>

* 컴포넌트 기반 방법론
  <br> - 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 <b>새로운 애플리케이션을 만드는 방법론이다</b>

* 수학적 산정 기법(상향식 비용 산정 기법)
  * <b>주요 수학적 산정 기법</b>
  <br> - COCOMO 모형 
  <br> - Putnam 모형
  <br> - 기능 점수(FP) 모형

* Putnam 모형
  <br> - <b>소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형</b>
  <br> - 푸트남(Putnam)이 제안한 것, 생명 주기 예측 모형이라고 함
  <br> - Rayleigh-Norden 곡선의 노력 분포도를 기초로 함

* 기능 점수 모형
  <br> - <b>소프트웨어의 기능을 증대시키는 요인별</b>로 가중치를 부여, 점수를 산출 <b>기능 점수(FP)를 구한 후 비용을 산정하는 기법</b>
  <br> - <b>소프트웨어 기능 증대 요인</b>
    * 자료 입력(입력 양식)
    * 정보 출력(출력 보고서)
    * 명령어(사용자 질의수)
    * 데이터 파일
    * 필요한 외부 루틴과의 인터페이스

* 비용 산정 자동화 추정 도구
  <br> - <b>SLIM</b> : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기로초 하여 개발
  <br> - <b>ESTIMACS</b> : 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발

* CPM : <b>작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법</b>
  <br> ※ 임계 경로 = 최장 경로

* CMMI : <b>소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델</b>(초관정정최)
  <br> - <b>초기</b> -> <b>관리</b> -> <b>정의</b> -> <b>정량적 관리</b>-> <b>최적화</b>

* 소프트웨어 개발 프레임 워크 : <b>소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 제공해주는 반제품 형태의 소프트웨어 시스템</b>

* 소프트웨어 개발 프레임워크의 특성
  <br> * <b>모듈화</b>
    <br> &nbsp;&nbsp; - 캡슐화를 통해 모듈화를 강화
    <br> &nbsp;&nbsp; - 유지보수가 용이
  <br> * <b>재사용성</b>
    <br> &nbsp;&nbsp; - 재사용 가능한 모듈들을 제공
  <br> * <b>확장성</b>
    <br> &nbsp;&nbsp; - 다형성을 통한 인터페이스 확장이 가능
  <br> * <b>제어의 역흐름</b>
    <br> &nbsp;&nbsp; - 객체들의 제어를 프레임워크에 넘겨서 생산성을 향상
    </div>
</details>



### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 2-1 데이터 입·출력 구현 1
### 중요도 <span style="color:red">A</span><br>

<details>
    <summary></summary>
    <div markdown="1">
    
* 스키마 : <b>데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것</b>
   종류 | 내용 |
  ---------|----------|
   외부 스키마 | 사용자나 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것 |
   개념 스키마<span style="color:red"><small> * 필기 21.3</small></span> | ·데이터베이스의 전체적인 논리적 구조 <br> ·모든 응용프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함 |
   내부 스키마<span style="color:red"><small> * 필기 20.9</small></span> | ·물리적 저장장치의 입장에서 본 데이터베이스 구조<br> ·실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄 |

* 데이터베이스 설계 순서(분석 -> 개논물 설계 -> 구현)
  <br> : 분석 -> 개념적 설계 -> 논리적 설계 -> 물리적 설계 -> 구현

* 개념적 설계
  <br> - <b>현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정</b>
  <br> - 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
  <br> - 요구 조건 명세를 E-R다이어그램으로 작성  
  <br> - 개념 스키마를 설계하는 단계

* 논리적 설계
  <br> - <b>현실 세계에서 발생하는 자료를 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정</b>
  <br> - 개념 스키마를 평가 및 정제 

* 물리적 설계
  <br> - <b>논리적 설계에서 논리적 구조로 표현된 데이터를 물리적 구조의 데이터로 변환하는 과정</b>

* 데이터 모델
  <br> - <b>현실 세계의 정보들을 체계적으로 표현한 개념적 모형</b>
  <br> - 데이터 모델에 표시할 요소<br>
   요소 | 내용 |
  ---------|----------|
    구조(Structure) | 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현 |
    연산(Operation) | 데이터베이스에 젖아된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구 |
    제약조건(Constraint) | 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건 |

* 관계형 데이터베이스의 릴레이션 구조
<br> * 릴레이션 : 데이터들을 표의 형태로 표현한 것
   속성1 | 속성2 |
  ---------|----------|
   튜플1 | 도메인 | 
   튜플2 | 도메인 |
   튜플3 | 도메인 |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - <b>속성들의 행 : 릴레이션 스키마</b>
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - <b>튜플들의 열 : 릴레이션 인스턴스</b>
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - <b>도메인들의 열 : 도메인</b>
<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - <b>릴레이션 스키마 + 릴레이션 인스턴스 = 릴레이션</b>

* 튜플 
  <br> - <b>릴레이션을 구성하는 각각의 행</b>
  <br> - 튜플의 수를 카디널리티, 기수, 대응수 라고도 함

* 속성
  <br> - <b>데이터베이스를 구성하는 가장 작은 논리적 단위</b>
  <br> - 개체의 특성을 기술
  <br> - 속성의 수 = 디그리 = 차수

* 후보키
  <br> - 릴레이션을 구성하는 <b>속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합</b>
  <br> - 유일성과 최소성을 모두 만족시켜야 함
  <br> - <b>유일성</b> : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함
  <br> - <b>최소성</b> : 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 함

* 슈퍼키
  <br> - 한 릴레이션 내에 있는 <b>속성들의 집합으로 구성된 키</b>
  <br> - 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만 최소성은 만족하지 못함

* 관계대수의 순수 관계 연산자
  * Select
    <br> - 선택조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
    <br> - <b>기호</b> : σ

  * Project
    <br> - 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
    <br> - <b>기호</b> : π

  * Join
    <br> - 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
    <br> - <b>기호</b> : ▷◁

  * Division
    <br> - 릴레이션 A, B가 있을때 릴레이션 B의 조건에 맞는 것들만 릴레이션 A에서 분리하여 프로젝션을 하는 연산
    <br> - <b>기호</b> : ÷

* 이상
  <br> - <b>데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상</b>
  <br> - <b>삽입 이상</b> : 테이블에 데이터를 삽입 할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
  <br> - <b>삭제 이상</b> : 테이블에서 튜플을 삭제 할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상
  <br> - <b>갱신 이상</b> : 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상

* 반정규화 - <b>정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위</b>

* 트랜잭션의 특징
   특성 | 의미 |
  ---------|----------|
   원자성(Atomicity) | 트랜잭션의 연상은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 함 |
   일관성(Consistency) | 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환 |
   독립성, 격리성, 순차성(Isolation) | 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음 |
   영속성, 지속성(Durability) | 시스템이 고장나더라도 영구적으로 반영되어야함 |
    </div>
</details>


### 중요도 <span style="color:#0000ff">B</span><br>

<details>
    <summary></summary>
    <div markdown="1">
    
* E-R 다이어그램
<br>
   기호이름 | 의미 |
  ---------|----------|
   사각형<span style="color:red"><small> * 필기 21.5, 21.3, 20.9, 20.6</small></span> | 개체 타입 |
   마름모<span style="color:red"><small> * 필기 21.5, 21.3, 20.9, 20.5</small></span> | 관계 타입 |
   타원<span style="color:red"><small> * 필기 21.5, 21.3, 20.9, 20.5</small></span> | 속성 |
   이중 타원 | 다중값 속성(복합 속성) |
   밑줄 타원 | 기본키 속성 |
   복수 타원 | 복합 속성 |
   관계 | 1:1 등의 개체간 관계에 대한 관계 기술 |
   선, 링크<span style="color:red"><small> * 필기 21.5, 21.3, 20.9, 20.5</small></span> | 개체 타입과 속성을 연결 |

* 외래키
  <br> - <b>다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합</b>

* 무결성
  <br> - <b>데이터베이스에 저장된 데이터 값과</b> 그것이 표현하는 <b>현실 세계의 실제값이 일치하는 정확성</b>을 의미
  <br> - <b>개체 무결성</b> : 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정
  <br> - <b>참조 무결성</b> : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정

* 관계대수
  <br> - 관계형 데이터베이스에서 <b>원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어</b>

* 관계대수의 일반 집합 연산자
  * 합집합(UNION)
    <br> - 합집합 구한 후 중복되는 튜플은 제거하는 연산
    <br> - <b>기호</b> : ⋃

  * 교집합(INTERSECTION)
    <br> - 튜플의 교집합을 구하는 연산
    <br> - <b>기호</b> : ⋂⨉

  * 차집합(DIFFERENCE)
    <br> - 존재하는 튜플의 차집합을 구하는 연산
    <br> - <b>기호</b> : ㅡ

  * 교차곱(CARTESIAN PRODUCT)<span style="color:red"><small> * 필기 21.8 21.5</small></span>
    <br> - 교차곱의 디그리(속성의 수) = 두 릴레이션의 디그리를 더한 것
    <br> - 카디널리티 = 두 릴레이션의 카디널리티를 곱한 것
    <br> - <b>기호</b> : ⨉

* 함수적 종속<span style="color:red"><small> * 필기 21.8</small></span>
  <br> - 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을때 Y는 X에 함수적 종속 
  <br> - 기호 : X -> Y

* 완전 함수적 종속
  <br> - Y가 X전체에 대해 함수적 종속이면서 X의 어떠한 진부분 집합 Z에도 함수정 종속이 아닐 때를 말함

* 부분 함수적 종속
  <br> - Y가 X전체에 대해 함수적 종속이면서 X의 어떠한 진부분 집합 Z에도 함수정 종속일 때를 말함

* 정규화
  <br> - <b>테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정</b>

* 정규화 과정 정리
  <br> - <b>도부이결다조</b>, 비정규릴레이션 123 B 45<br>
비정규 릴레이션 -> (도메인이 원자값)1NF -> (부분적 함수 종속 제거)2NF -> (이행적 함수 종속 제거)3NF -> (결정자이면서 후보키가 아닌것 제거)BCNF -> (다치 종속 제거)4NF -> (조인 종속성 이용)5NF

* 시스템카탈로그 - <b>다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스</b>, 메타데이터라고도 함

* 트랜잭션 - <b>논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들</b>

* CRUD분석  
  <br> - <b>프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는것</b>
  <br> - 생성, 읽기, 갱신, 삭제

* 인덱스
  <br> - <b>데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터</b>
    </div>
</details>





### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 2-2 데이터 입·출력 구현 2
### 중요도 <span style="color:red">A</span><br>

<details>
    <summary></summary>
    <div markdown="1">
    
* 뷰
  <br> - <b>하나 이상의 기본 테이블로부터 유도된 가상테이블</b>
  <br> - CREATE 문으로 정의, DROP 문으로 제거

* 분산 데이터베이스의 목표(위중병장 투명성)
  * 위치 투명성</b> : 실제위치 알 필요X 논리적인 명칭만으로 엑세스 가능
  * 중복 투명성</b> : 동일 데이터가 중복되어 있더라도 하나의 데이터만 존재하는 것처럼 사용
  * 병행 투명성</b> : 다수의 트랜잭션들이 동시에 실현되더라도 트랜잭션의 결과는 영향X 
  * 장애 투명성</b> : 장애에도 불구하고 트랜잭션 정확하게 처리

* RTO/RPO
  * RTO(Recovery Time Objective, 목표 복구 시간)</b> : 복구되어 가동될 때까지의 소요 시간을 의미함 <br>&nbsp; ex) 장애 발생 후 6시간 내 복구 가능
  * RPO(Recovery Point Objective, 목표 복구 시점)</b> : 데이터를 복구할 수 있는 기준점
  <br>&nbsp; ex) 지난 주 금요일에 백업시켜 둔 복원 시점으로 복구 가능

* 암호화
  * <b>암호화(Encryption) 과정</b> : 평문 -> 암호문
  * <b>복호화(Decryption) 과정</b> : 암호문 -> 평문
  * <b>암호화 기법</b>
    * 개인키 암호 방식
    * 공개키 암호 방식

* 임의 접근통제(DAC)
  <br> - <b>데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식</b>
  <br> - 데이터 소유자가 접근통제 권한을 지정하고 제어

* 강제 접근통제(MAC)
  <br> - <b>주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식</b>
  <br> - 시스템이 접근통제 권한을 지정

* 스택
  <br> - <b>리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조</b>
  <br> - 후입선출(LIFO)
  <br> - 오버플로 : 공간이 없는 상태에서 삽입될 경우
  <br> - 언더플로 : 삭제할 데이터가 없는 상태에서 삭제될 경우

* 트리 관련 용어
  * 노드 : 트리의 기본 요소, 동그라미
  * 근 노드 : 트리의 맨 위에 있는 노드
  * 디그리(차수) : 각 노드에서 뻗어나온 가지의 수
  * 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수
  * 단말 노드 = 잎 노드 : 자식이 하나도 없는 노드, 즉 Degree가 0인 노드
  * Level : 근 노드의 Level을 1로 가정한 후 어떤 레벨이 L이면 자식 노드는 L+1
  * 깊이 : Tree에서 노드가 가질 수 있는 최대의 레벨

* 삽입 정렬
  <br> - <b>이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식</b>
  <br>ex) 초기 85624
  <br> 1회전 : 85624 -> 58624
  <br> 2회전 : 58624 -> 56824
  <br> 3회전 : 56824 -> 25684
  <br> 4회전 : 24684 -> 24568
  <br> - n+1 번째 숫자와 첫번째 숫자부터 n번째 숫자까지 비교하여 작은수와 교체

* 선택 정렬
  <br> - <b>최소값을 찾아 첫 번째 레코드 위치에 놓고, 다시 최소값을 찾아 두번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식</b>
  <br>ex) 초기 85624
  <br> 1회전 : 58624 -> 58624 -> 28654 -> 28654
  <br> 2회전 : 26854 -> 25864 -> 24865
  <br> 3회전 : 24685 -> 24586
  <br> 4회전 : 24568
  <br> - n 위치의 숫자와 그 오른쪽 부터 끝까지 비교해서 작은수와 교체

* 버블 정렬
  <br> - <b>인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식</b>
  <br>ex) 초기 85624
  <br> 1회전 : 58624 -> 56824 -> 56284 -> 56248
  <br> 2회전 : 56248 -> 52648 -> 52468
  <br> 3회전 : 25468 -> 24568
  <br> 4회전 : 24568
  <br> - 앞에서부터 2개씩 비교 1번2번, 2번3번, 3번4번~
    </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>

<details>
    <summary></summary>
    <div markdown="1">
    
* 파티션의 종류
  * 범위 분할</b>
  * 해시 분할</b>
  * 조합 분할</b> : 범위분할한 다음 해시분할

* DAS
  <br> - <b>서버와 저장장치를 전용 케이블로 직접 연결하는 방식</b>

* SAN
  <br> - <b>서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식</b>

* 방향/무방향 그래프의 최대 간선 수(n은 정점의 개수)
  * 방향 그래프의 최대 간선 수 : n(n-1)
  * 무방향 그래프의 최대 간선 수 : n(n-1)/2

* 트리
  <br> - <b>정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태</b>

* Preorder 운행법
  <br> - <b>Root -> Left -> Right 순으로 운행하며 노드들을 찾아가는 방법</b>

* Inorder 운행법
  <br> - <b>Left -> Root -> Right 순으로 운행하며 노드들을 찾아가는 방법</b>

* Postorder 운행법(중요X)
  <br> - <b>Left -> light -> Root 순으로 운행하며 노드들을 찾아가는 방법</b>

* Postfix로 표기된 수식을 Infix로 바꾸기
  <br> - 연산자를 피연산자 두개 가운데로 옮기면 됨
  <br>ex) : A B C - / D E F + * + &nbsp;<b>=></b>&nbsp; A / (B - C) + D * (E + F)
  <br>ex) : 34*56*+ -> (34*)(56*)+ -> (3*4)+(5*6) = 42
  
* 퀵 정렬
  <br> - <b>키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 정렬 방식</b>

* 힙 정렬
  <br> - <b>전이진(완전 이진) 트리를 이용한 정렬 방식</b>

* 2-Way 합병 정렬
  <br> - <b>두 개의 파일을 한 개의 파일로 합병하는 정렬 방식</b>
  <br> - 시간복잡도 O(nlog<sub>2</sub>n)
    </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 3장 통합 구현
### 중요도 <span style="color:red">A</span><br>

<details>
    <summary></summary>
    <div markdown="1">
    
* 연계 서버 / 송·수신 시스템
  * <b>연계 서버</b> : 데이터를 전송 형식에 맞게 변환하고 송·수신을 수행하는 등 송·수신과 관련된 모든 처리 수행
  * <b>송신 시스템</b> : 인터페이스 테이블 또는 파일의 데이터를 전송 형식에 맞도록 변환 및 송신을 수행하는 시스템(인터페이스를 구성하는 시스템)
  * <b>수신 시스템</b> : 수신 데이터를 인터페이스 테이블이나 파일로 생성하는 시스템

* XML
  <br> - <b>특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어</b>

* SOAP
  <br> - <b>네트워크 상에서 HTTP/HTTPS, SMTP 등을 이용하여 XMl을 교환하기 위한 통신규약</b>

* WSDL
  <br> - <b>웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어</b>
  <br> - XML로 작성되며, UDDI의 기초가 됨
    </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
  
  * 연계 매커니즘
  * <b>로그</b> : 사용자가 컴퓨터에 요청한 명령이나 컴퓨터가 데이터를 처리하는 과정 및 결과등을 기록으로 남긴 것
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 4-1 서버 프로그램 구현1
### 중요도 <span style="color:red">A</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    


* 모듈화
  <br> - <b>시스템의 기능들을 모듈 단위로 나누는 것</b>
  <br> - 결합도 최소화 / 응집도 최대화

* 추상화
  <br> - <b>전체적이고 포괄적인 개념을 설계한 후 구체화시켜 나가는 것</b>
  <br> - 추상화의 유형
  <br> - <b>과정 추상화</b>
  <br> - <b>자료 추상화</b>
  <br> - <b>제어 추상화</b>

* 정보은닉
  <br> - <b>한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법</b>

* 파이프-필터 패턴
  <br> - <b>데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴</b>
  <br> 서브시템이 입력 데이터를 받아 처리하고 결과를 다음 시스템으로 넘겨주는 과정을 반복하는 패턴

* 클래스
  <br> - <b>공통된 속성과 연산을 갖는 객체의 집합</b>

* 캡슐화
  <br> - <b>외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것</b>
  <br> - 변경 발생시 오류의 파급 효과가 적다

* 객체지향 분석의 방법론
  * <b>Rumbaugh(럼바우) 방법</b> : 분석 활동을 <b>객</b>체 모델, <b>동</b>적 모델, <b>기</b>능 모델로 나누어 수행
  * <b>Booch(부치) 방법</b> : 미시적, 거시적 개발 프로세스를 모두 사용
  * <b>Jacobson 방법</b> : 유스케이스를 강조하여 사용
  * <b>Coad와 Yourdon 방법</b><span style="color:red"><small> * 필기 21.3, 20.6</small></span> : E-R 다이어그램을 사용
  * <b>Wrifs-Brock 방법</b> : 분석과 설계간의 구분 X

* 럼바우의 분석 기법
  * <b>모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링</b>하는 기법
  * 분석 활동은 '객체 모델링 -> 동적 모델링 -> 기능 모델링' 순서
    * 객체 모델링(Object Modeling) = 정보 모델링(Information Modeling) : 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의관계를 규정하여 객체 다이어그램으로 표시하는 모델링
    <br>ex) ER다이어그램
    * 동적 모델링(Dynamic Modeling) : 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
    <br>ex) 상태 변화도(STD)
    * 기능 모델링(Functional Modeling) : 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
  </div>
</details>


### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    

* 상위 설계와 하위 설계<br>
    &nbsp; | 상위 설계<span style="color:red"><small> * 20.9</small></span> | 하위 설계 |
  ---------|----------| ----------------|
   별칭 | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계 |
   설계 대상 | 시스템의 전체적인 구조 | 시스템의 내부 구조 및 행위 |
   세부 목록 | 자료구조, DB, 인터페이스 | 컴포넌트, 자료구조, 알고리즘 |

* 소프트웨어 아키텍처의 품질 속성
  <br> - <b>시스템 측면</b><span style="color:red"><small> * 필기 21.5</small></span> : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
  <br> - <b>비즈니스 측면</b> : 시장 적시성, 비용과혜택, 예상 시스템 수명, 목표 시장
  <br> - <b>아키텍처 측면</b> : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 

* (컴포넌트 설계시)협약(Contract)에 의한 설계
  <br> - 를 따를 경우 명세에 포함될 조건
  <br> - <b>선행 조건</b>
  <br> - <b>결과 조건</b>
  <br> - <b>불변 조건</b>

* 레이어 패턴
  <br> - <b>시스템을 계층으로 구분하여 구성하는 패턴</b>

* 클라이언트-서버 패턴
  <br> - <b>하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴</b>

* 모델-뷰-컨트롤러 패턴
  <br> - <b>서비시스템을 모델, 뷰, 컨트롤러로 구조화 하는 패턴</b>

* 기타 패턴
  * 마스터-슬레이브 패턴 : 병렬 컴퓨팅 시스템
  * 인터프리터 패턴 : 번역기, 언어개발

* 메시지
  <br> - <b>객체의 동작나 연산을 일으키는 외부의 요구 사항</b>

* 상속
  <br> - <b>상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것</b>

* 다형성
  <br> - <b>각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력</b>
  <br> - 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질

* 연관성
  <br> - <b>두 개 이상의 객체들이 상호 참조하는 관계</b>
  <br>* 연관성의 종류
   종류 | 의미 | 특징 |
  ---------|----------| ----------------|
   is member of | 연관화 | 2개 이상의 객체가 상호 관련되어 있음을 의미 |
   is instance of | 분류화 | 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것 |
   is part of<span style="color:red"><small> * 필기 20.8</small></span> | 집단화 | 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것 |
   is a | 일반화<br> 특수화/상세화 | 공통적인 성질들로 추상화한 상위객체를 구성하는 것<br> 상위 객체를 구체화하여 하위 객체를 구성하는 것 |

* 객체지향 분석
  <br> - 사용자의 요구사항과 관련된 <b>객체, 속성, 연산, 관계 등을 정의하여 모델링</b>하는 작업

* 객체지향 설계 원칙(SOLID 원칙)
  * SRP(단일 책임 원칙) : 객체는 단 하나의 책임만 가져야 한다는 원칙
  * OCP(개방 폐쇄 원칙) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
  * LSP(리스코프 치환 원칙) : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙
  * ISP(인터페이스 분리 원칙) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
  * DIP(의존 역전 원칙) : 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 4-2 서버 프로그램 구현2
### 중요도 <span style="color:red">A</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
    

* 팬인 : <b>어떤 모듈을 제어하는 모듈의 수</b> = <b>모듈에 In 되는 Line 개수 = 들어오는 선의 수</b>
 
* 팬아웃 : <b>어떤 모듈에 의해 제어되는 모듈의 수</b> = <b>모듈에 out 되는 Line 개수 = 나가는 선의 수</b>

* IPC : <b>모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합</b>
 
* 테스트 케이스 : <b>소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서</b>
  
* 디자인 패턴 : <b>모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제</b>를 의미<br>
  GOF의 디자인 패턴 : 생성 패턴, 구조 패턴, 행위 패턴

* 생성 패턴 
  * 추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존X, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹
  * 빌더(Builder) : 작게 분리된 인스턴스를 조합하여 객체를 생성하는 패턴
  * 팩토리 메소드(Factory Method) : 객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화한 패턴
  * 프로토타입(Prototype) : 원본 객체를 복제하는 방법
  * 싱글톤(Singleton) : 어디서든 참조O 여러 프로세스 동시에 참조X, 클래스 내에서 인스턴스가 하나뿐임을 보장
<br><br>

* 구조 패턴
  * 어댑터(Adapter) : 호환성이 없는 클래스의 인터페이스를 다른클래스가 이용할수 있도록 변환해주는 패턴
  * 브리지(Bridge) : 구현부에서 추상층을 분리, 서로가 독립적으로 확장 할 수 있도록 구상한 패턴
  * 컴포지트(Composite) : 복합 객체와 단일 객체를 구분없이 다루고자 사용할 때
  * 데코레이터(Decorator) : 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
  * 퍼싸드(Facade) : 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용 할 수 있도록 하는 패턴
  * 플라이웨이트(Flyweight) : 인스턴스를 필요할 때마다 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
  * 프록시(Proxy) : 접근이 어려운 객체와 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
<br><br>

* 행위 패턴
  * 책임 연쇄 : 둘 이상의 객체가 존재하는데 한 객체가 처리못하면 다른 객체로 넘어가는 패턴
  * 커맨드 : 요청을 객체의 형태로 캡슐화, 필요한 정보를 저장 or 로그에 남기는 패턴
  * 인터프리터 : 언어에 문법 표현을 정의하는 패턴
  * 반복자 : 동일한 인터페이스를 사용하도록 하는 패턴
  * 중재자 : 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
  * 메멘토 : 특정 시점에서 객체화, 그 시점으로 돌릴수있음
  * 옵서버 : 상태가 변화하면 상속된 객체들도 변화된 상태를 전달 = 일대다의 의존성을 정의하는 패턴
  * 상태 : 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
  * 전략 : 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
  * 템플릿 메소드 : 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화 하는 구조의 패턴
  * 방문자 : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
  </div>
</details>


### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
    

* 모듈 : <b>모듈화를 통해 분리된 시스템의 각 기능</b>, 하나 또는 몇개의 논리적인 기능을 수행하기 위한 명령어들의 집합

* 결합도 : <b>모듈 간에 상호 의존하는 정도</b><br>
* 결합도 : 약함 -> 강함<br>
<span style="color:#0000ff">자 -> 스 -> 제 -> 외 -> 공 -> 내 = 자스제 외공내</span><br>
  내용 결합도 : 내부 기능 및 그 내부 자료를 <span style="color:#0000ff">직접 참조 or 수정</span><br>
  공통 결합도 :  공통 데이터 영역을 여러 모듈이 사용, <span style="color:#0000ff">전역변수</span>를 사용하여 전역변수를 갱신하는방식<br>
  외부 결합도 : 선언한 데이터(변수)를 <span style="color:#0000ff">외부의 다른 모듈에서 참조</span><br>
  제어 결합도 : 내부의 논리적인 흐름을 제어하기 위해 <span style="color:#0000ff">제어 신호</span>나 <span style="color:#0000ff">제어요소</span>를 전달<br>
  스탬프 결합도 : <span style="color:#0000ff">배열 or 레코드 등의 자료구조</span> 전달<br>
  자료 결합도 : <span style="color:#0000ff">자료 요소로만 구성</span>될 때<br>
   
* 응집도 : <b>모듈의 내부요소들이 서로 관련되어 있는 정도</b><br>
* 응집도 : 약함 -> 강함<br>
<span style="color:#0000ff">우 -> 논 -> 시 -> 절 -> 교 -> 순 -> 기 = 우논시절 교순기</span><br>
기능적 응집도 : 모든 기능 요소들이 <span style="color:#0000ff">단일 문제</span>와 연관<br>
 순차적 응집도 : 출력 데이터를 그다음 활동의 <span style="color:#0000ff">입력데이터로</span>사용할때<br>
 교환적 응집도 : <span style="color:#0000ff">동일한 입력,출력 사용</span> 하여 서로 <span style="color:#0000ff">다른기능을 수행</span>하는 구성 요소들이 모였을 경우<br>
 절차적 응집도 : 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 <span style="color:#0000ff">기능적으로 연관성은 없지만 순차적으로 수행할 경우</span><br>
 시간적 응집도 : <span style="color:#0000ff">특정 시간</span>에 처리되는 기능을 모아 하나로 작성할 때<br>
 논리적 응집도 : <span style="color:#0000ff">유사한 성격 or 특정 형태</span>로 분류되는 처리요소들로 형성되는 경우<br>
 우연적 응집도 : 서로 <span style="color:#0000ff">관련 없는 요소</span>로 구성<br>

* N-S차트 : <b>논리의 기술에 중점을 두고 도형을 이용해 표현</b>하는 방법 / 연속, 선택 및 다중 선택, 반복의 3가지 제어논리구조로 표현

* 공통모듈명세시 준수해야할 명세 기법<br>
  정확성 : 해당 기능이 필요하다는 것을 알 수 있도록 작성함<br>
  명확성 : 중의적으로 해석되지 않도록 작성함<br>
  완전성 : 시스템 구현을 위해 필요한 모든것을 기술함<br>
  일관성 : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성함<br>
  추적성 : 기능에 대한 요구사항의 출처, 관계등을 파악할수 있도록 작성<br>

* 재사용 : <b>이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화</b> 하는 작업<br>
  재사용 규모에 따른 분류 : 함수와 객체, 컴포넌트, 애플리케이션

* 코드 : <b>자료의 분류·조합·집계·추출을 용이하게 하기 위해 사용하는 기호</b><br>
  코드의 주요 기능<br>
  식분 배표간
  식별, 분류, 배열, 표준화, 간소화

* 코드의 종류<br>
  순차 코드 : 일련번호를 부여하는 방법<br>
  블록 코드 : 공통성이 있는것끼리 블록으로 구분<br>
  10진 코드 : 10진분할하는 방법을 반복<br>
  그룹분류 코드 : 기준에따라 구분후 일련번호 부여<br>
  연상 코드 : 명칭, 숫자, 문자, 기호이용<br>
  표의 숫자 코드 : 물리적 수치를 이용<br>
  합성 코드 : 2개이상의 코드를 조합<br>

* 배치 프로그램 : 사용자와의 상호 작용 없이 <b>여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램</b>
* 배치프로그램의 필수 요소
  * 대용량 데이터 : 대용량 데이터의 처리 능력
  * 자동화 : 사용자의 개입 없는 작업의 수행
  * 견고성 : 시스템의 중단없는 지속 능력
  * 안정성/신뢰성 : 오류 추적 능력
  * 성능 : 작업 수행 능력
  </div>
</details>

<!-- -------------------------------------------------------------- --->

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 5 인터페이스 구현

### 중요도 <span style="color:red">A</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
    

* 미들웨어의 종류<br>
  DRM TOW = DRM 토우
  * DB : 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어
  * RPC : 프로시저를 사용
  * MOM : 메시지기반의 비동기형 메시지를 전달하는 미들웨어
  * TP-Monitor : 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어
  * ORB : 코바(CORBA)표준 스펙을 구현한 객체지향 미들웨어
  * WAS : 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해
<br><br>
* EAI : <b>기업 내 각종 애플리케이션 및 플랫폼 간 상호 연동이 가능하게 해주는 솔루션</b>
  * Point-to-Point : 가장 기본적인 애플리케이션 통합방식, 1:1로 연결
  * Hub & Spoke : <b>단일 접점(중앙 집중형)</b>인 허브 시스템을 통해 데이터 전송
  * Message Bus : 애플리케이션 사이에 미들웨어를 둠, 대용량 처리가 가능
  * Bus Hybrid : Hub & Spoke와 Message Bus의 혼합방식
<br><br>
* JSON : <b>데이터 객체를 속성 · 값의 쌍 형태로 표현하는 개방형 표준 포맷</b>, AJAX에서 XML을 대체하여 사용됨
* AJAX : 자바스크립트를 사용하여 <b>클라이언트와 서버간에 XML 데이터를 주고받는 비동기 통신기술</b>
* IPsec / SSL / S-HTTP = ISS
  * IPsec(IP Security) : 네트워크 계층에서 <b>IP 패킷 단위</b> 의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜
  * SSL(Secure Sockets Layer) : <b>TCP/IP 계층</b>과 <b>애플리케이션 계층</b> 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜
  * S-HTTP(Secure Hypertext Transfer Protocol) : 클라이언트와 서버간에 전송되는 모든 메시지를 암호화 하는 프로토콜
* 인터페이스 구현 검증 도구 : 통합테스트가 필요하며 통합 테스트를 하기 위해 사용하는 테스트 자동화도구<br>
  xSFN Sw
  * xUnit : Java용 : JUnit, C++용 : CppUnit, .Net용 : NUnit
  * STAF : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
  * FitNesse : 웹 기반
  * NTAF : Fitness(협업) + STAF(재사용 및 확장성) 장점을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
  * Selenium : 다양한 브라우저 및 개발언어 지원
  * watir : Ruby(인터프리터 방식의 객체 지향 스크립트언어)를 사용하는 애플리케이션 테스트 프레임워크
  </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
    

* 요구사항 검증 방법
  * 요구사항 검토
    * 동료검토 : 동료(이해관계자)들이 들으면서 결함 발견
    * 워크스루 : 검토 회의 전 요구사항 명세서를 미리배포, 사전 검터 후 짧은 검토 회의를 통해 결함 발견
    * 인스펙션 : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서 확인
  * 프로토타이핑 : 견본품을 만들어 최종 결과물 예측
  * 테스트 설계 : 테스트 케이스를 생성하여 요구사항이 현실적으로 가능한지 검토
  * CASE 도구 활용 : 일관성 분석을 통해 확인

* 인터페이스 요구사항 검증의 주요 항목<br>
  완일 명기 검추변
  * 완정성 : 완전히 반영되었는가?
  * 일관성 : 일관성을 유지하고 있는가?
  * 명확성 : 명확히 이해할수있는가?
  * 기능성 : 어떻게 보다 무엇을 에 중점을 두고있는가?
  * 검증가능성 : 검증할수있는가?
  * 추적가능성 : 명세서와 설계서를 추적할 수 있는가?
  * 변경용이성 : 변경이 쉽도록 작성되었는가?

* 미들웨어 : <b>운영체제와 응용 프로그램</b> or 서버와 클라이언트 <b>사이에서 다양한 서비스를 제공하는 소프트웨어</b>

* 인터페이스 보안 기능 적용<br>
  인터페이스 보안 : <b>인터페이스 보안 취약점을 분석한 후 적절한 보안 기능을 적용하는 것</b>
  * 네트워크 영역 : 암호화는 IPSec, SSL, S-HTTP 등의 방식으로 적용

* 데이터 무결성 검사 도구<br>
  TAS CSF
  * Tripwire
  * AIDE
  * Samhain
  * Claymore
  * Slipwire
  * Fcheck

* APM : <b>애플리케이션의 성능 관리를 위해 다양한 모니터링 기능을 제공하는 도구</b>
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 6장 화면 설계

### 중요도 <span style="color:red">A</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
    

* UI : <b>사용자와 시스템 간의 상호작용이 이뤄지도록 도와주는 장치나 소프트웨어</b>
* UX : <b>사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험</b>
* UI의 구분
  * CLI : 명령과 출력이 <b>텍스트 형태</b>로 이루어진 인터페이스
  * GUI : 마우스로 선택, 작업수행하는 <b>그래픽 환경</b>의 인터페이스 
  * NUI : 별도의 장치 없이 사용자의 <b>자연스러운 움직임</b>으로 기기를 조작하는 인터페이스
* UI의 기본 원칙<br>
 직유 학유
 * 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
 * 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
 * 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함
 * 유효성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함
* 품질 요구사항<br>
  소프트웨어 품질 관련 표준(국제표준) 
  * ISO/IEC 9126 : 소프트웨어의 품질 특성과 평가를 위한 국제표준
  * ISO/IEC 25010 : 9126에 호환성과 보안성을 강화 
  * ISO/IEC 12119 : 패키지 소프트웨어의 일반적인 품질 요구사항 및 테스트
  * ISO/IEC 14598 : 소프트웨어 품질의 측정과 평가에 피료한 절차를 규정 

* ISO/IEC 9126의 소프트웨어 품질 특성
  * 기능성 : 사용자의 요구사항을 만족하는 기능을 제공하는지 여부
  * 신뢰성 : 주어진 시간동안 주어진 기능을 오류 없이 수행할 수 있는 정도
  * 사용성 : 향후 다시 사용하고 싶은 정도
  * 효율성 : 얼마나 빠르게
  * 유지 보수성 : 개선, 확장할수있는정도
  * 이식성 : 다른 환경에서도 얼마나 쉽게 적용할수있는지
  </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
    

* UI 설계도구
  * 와이어프레임 : <b>페이지에 대한 개략적인 레이아웃 등 뼈대를설계하는 도구</b>
  * 목업 : 와이어프레임보다 좀 더 <b>실제 화면과 유사하게 만든 정적인 형태의 모형</b>
  * 스토리보드 : <b>와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서</b>
  * 프로토타입 : <b>실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형</b>
  </div>
</details>
  
### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 7장 애플리케이션 테스트 관리

### 중요도 <span style="color:red">A</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* 애플리케이션 테스트의 기본원리
  * 파레토 법칙 : 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙
  * 살충제 패러독스 : 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상
  * 오류-부재의 궤변 : 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없는것
* 프로그램 실행 여부에 따른 테스트
  * 정적 테스트
    * 프로그램, 애플리케이션을 실행하지 않고 명세서나 소스코드를 대상으로 분석하는 테스트
    * 종류 : 워크스루, 인스펙션, 코드검사
  * 동적 테스트
    * 프로그램을 실행하여 오류를 찾는 테스트
    * 종류 : 블랙박스 테스트, 화이트박스 테스트
* 시각에 따른 테스트
  * 검증 테스트
    * 개발자의 시각에서 제품의 생산과정을 테스트
    * 제품이 명세서대로 완성됐는지 테스트
  * 확인 테스트
    * 사용자의 시각에서 생상된 제품의 결과를 테스트
    * 사용자가 요구한대로 제품이 완성됐는지, 정상적으로 동작하는지 테스트
* 목적에 따른 테스트
  * 회복 테스트 : 시스템에 여러가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지
  * 안전 테스트 : 불법적인 침입으로부터 시스템을 보호할수있는지
  * 강도 테스트 : 과부하 시에도 소프트웨어가 정상적으로 실행되는지
  * 성능 테스트 : 실시간 성능이나 전체적인 효율성을 진단 / 소프트웨어의 응답시간 처리량 등을 테스트
  * 구조 테스트 : 논리적인 경로, 소스코드의 복잡도 등을 평가
  * 회귀 테스트 : 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는
  * 병행 테스트 : 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는
* 화이트박스 테스트의 종류
  * 기초 경로 검사 : 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법이다
  * 제어 구조 검사
    * 조건 검사
    * 루프 검사
    * 데이터 흐름 검사
* 화이트박스 테스트의 검증 기준<br>
  문분조
  * 문장 검증 기준 : 모든 구문, 문장이 수행되도록
  * 분기 검증 기준 : 모든 조건문에 대해 조건식의 결과가 참(True)/거짓(False)일 때 수행되도록 구성하는 검증 기준
  * 조건 검증 기준 : 조건문에 포함된 개별 조건식이 참(True)/거짓(False)일 때 수행되도록 구성하는 검증 기준
  * 분기/조건 기준 : 분기검증기준과 조건 검증기준 모두 만족하는 설계
* 블랙박스 테스트 : <b>각 기능이 완전히 작동되는것을 입증하는 테스트</b>
* 블랙박스 테스트의 종류<br>
  동경 원오비
  * 동치 분할 검사 : 입력자료의 개수를 균등하게하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인
  * 경계값 분석 : 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트케이스로 선정하여 검사하는 기법
  * 원인-효과 그래프 검사 : 입력 데이터간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
  * 오류 예측 검사 : 과거의 경험이나 확인자의 감각으로 테스트하는 기법
  * 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법
* 개발 단계에 따른 애플리케이션 테스트
  * V-모델 : 소프트웨어 개발단계 + 애플리케이션 테스트
  * 소프트웨어 개발 단계 \ : 요구사항 -> 분석 -> 설계 -> 구현
  * 테스트 단계 / : 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트  = 단통시인
* 단위테스트 : <b>모듈이나 콤포넌트에 초점을 맞춰 테스트</b>
* 통합테스트 : <b>단위테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트</b>
  * 비점진적 통합방식 : 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어있음
  * 점진적 통합방식 : 모듈 단위로 단계적으로 통합하면서 테스트
* 하향식 통합 테스트 : <b>상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트</b>
  * 스텁(Stub) : 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
* 상향식 통합 테스트 : <b>하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트</b>
  * 테스트 드라이버 : 테스트 대상의 하위 모듈 호출, 파라미터전달, 수행후 결과를 도출하는 도구
* 테스트 오라클의 종류<br>
  참샘추일
  * 참 오라클 : 모든 테스트 케이스의 입력값에 대해 기대하는 결과를 제공
  * 샘플링 오라클 : 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 / 전수 테스트가 불가능한 경우
  * 추정 오라클 : 특정 테스트 케이스의 입력값에 대해 기대하는 결과를 제공, 나머지 입력 값들에 대해서는 추정으로 처리
  * 일관성 검사 오라클 : 애플리케이션에 변경이 있을 때 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클
* 소스 코드 품질 분석 도구
  * 정적 분석 도구 : 작성한 소스 코드를 실행하지 않고
  * 동적 분석 도구 : 작성한 소스 코드를 실행하여
  </div>
</details>


### 중요도 <span style="color:#0000ff">B</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* 화이트박스 테스트 : <b>원시코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법</b>
* 인수 테스트 : <b>사용자의 요구사항을 충족하는지에 중점을 두고 테스트</b>
  * 알파테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 행함 / 테스트는 통제된 환경, 사용자와 개발자가 함께 확인하면서 기록함
  * 베타테스트 : 선정된 최종 사용자가 여러 명의 사용자 앞에서 행함 / 실업무를 가지고 사용자가 테스트
* 테스트 오라클 : <b>테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법</b>
* 테스트 자동화 도구
  * 정적 분속 도구 
  * 테스트 실행 도구 
  * 성능 테스트 도구 : 가상의 사용자를 생성
  * 테스트 동제 도구 
  * 테스트 하네스 도구
* 결함 : <b>소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생되는것</b>
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 8장 SQL응용

### 중요도 <span style="color:red">A</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* CREATE INDEX
```sql
CREATE [UNIQUE] INDEX 인덱스명
ON 테이블명(속성명 [ASC|DESC] [,속성명 [ASC|DESC]])
[CLUSTER];
```

* ALTER TABLE
```
ALTER TABLE 테이블명 ADD 속성명 데이터타입 [DEFAULT '기본값'];
ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];
ALTER TABLE 테이블명 DROP COLUMN 속성명 [CASCADE];
```

* GRANT / REVOKE
  * GRANT : 권한 부여를 위한 명령어<br>
    REVOKE : 권한 취소를 위한 명령어
  * 권한 종류(권한_리스트) : ALL, SELECT, INSERT, DELETE, UPDATE등
  * WITH GRANT OPTION : 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여
  * GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소함
  * CASCADE : 권한 취소 시 부여받았던 사용자가 다른사용자에게 부여한 권한도 연쇄적으로 취소
```
GRANT 권한_리스트 ON 개체 TO 사용자 [WITH GRANT OPTION];
REVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE];
``` 

* ROLLBACk : <b>변경되었으나 아직 COMMIT되지 않은 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어</b>

* 삭제문 DELETE FROM
```
DELETE FROM 테이블명 [WHERE 조건];
```

  * 모든 레코드를 삭제할떄는 WHERE절 생략
  * 삭제해도 테이블 구조는 존재, 구조삭제는 DROP

* 갱신 UPDATE~ SET~
```
UPDATE 테이블명
SET 속성명=데이터 [, 속성명=데이터, ···]
[WHERE 조건];
```

* SELECT
  * PREDICATE : 검색할 튜플 수를 제한하는 명령어
    * ex) DISTINCT : 중복된 튜플이 있으면 그중 첫번째 한개만 표시
```
SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ···]
FROM 테이블명[, 테이블명 ···]
[WHERE 조건]
[GROUP BY 속성명, 속성명, ···]
[HAVING 조건]
[ORDER BY 속성명 [ASC|DESC]];
```

* 조건 지정 검색
  * 비교연산자
    * <> : 같지않다
  * 논리 연산자 : NOT, AND, OR
  * LIKE 연산자 : 대표 문자를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플을 검색하기 위해 사용
    * % : 모든 문자를 대표
    * _ : 문자 하나를 대표
    * \# : 숫자 하나를 대표
  * IN 연산자 : 필드의 값이 IN 연산자 수로 지정된 값과 같은 레코드만 검색하며 OR 연산을 수행한 결과와 같음<br> ex) 3,4학년의 조건 =  WHERE 학년 IN(3,4)

* 날짜데이터의경우 ''이아닌 ##으로 묶는다 ex) #01/01/1992#
* 정렬검색
```
SELECT *
FROM 사원
ORDER BY 부서 ASC, 이름 DESC;
```

* 그룹함수
 
명령어 | 기능 |
---------|----------|
 COUNT(속성명) | 그룹별 튜플 수를 구하는 함수 |
 SUM(속성명) | 그룹별 합계를 구하는 함수 |
 AVG(속성명) | 그룹별 평균를 구하는 함수 |
 MAX(속성명) | 그룹별 최대를 구하는 함수
 MIN(속성명) | 그룹별 최소를 구하는 함수
 STDDEV(속성명) | 그룹별 표준편차를 구하는 함수
 VARIANCE(속성명) | 그룹별 분산을 구하는 함수
  </div>
</details>


### 중요도 <span style="color:#0000ff">B</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* DDL : DB를 구축 or 수정할 목적으로 사용하는 언어
  * CREATE, ALTER, DROP

* DROP
  * CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거
  * RESTRICT : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소
```
DROP SCHEMA 스키마명 [CASCADE|RESTRICT];
DROP DOMAIN 도메인명 [CASCADE|RESTRICT];
DROP TABLE 테이블명 [CASCADE|RESTRICT];
DROP VIEW 뷰명 [CASCADE|RESTRICT];
DROP INDEX 인덱스명 [CASCADE|RESTRICT];
DROP CONSTRAINT 제약조건명;
```

* DCL : 데이터의 보안, 무결성, 회복, 병행제어 등을 정의하는데 사용하는 언어
  * COMMIT, ROLLBACK, GRANT, REVOKE

* DML : <b>저장된 데이터를 실질적으로 관리하는데 사용되는 언어</b>
   * SELECT, INSERT, DELETE, UPDATE

* 삽입문 INSERT INTO
```
INSERT INTO 테이블명([속성명1, 속성명2, ···])
VALUES (데이터1, 데이터2, ···);
```
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 9장 소프트웨어 개발 보안 구축

### 중요도 <span style="color:red">A</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* 소프트웨어 개발 보안 요소
  * 기밀성 : 인가된 사용자에게만 접근이 허용
  * 무결성 : 인가된 사용자만 수정가능
  * 가용성 : 인가된 사용자는 정보와 자원을 언제든 사용가능
* XSS : <b>악의적인 스크립트를 삽입하여 정보를 탈취, 비정상적인 기능 수행을 유발하는 보안 약점</b>
* 접근제어자 : public protected default private
* DES : <b>1975년 미국 NBS 발표 암호화 알고리즘</b>
* AES : <b>2001년 미국표준기술연구소 발표 암호화 알고리즘</b>
* 해시 : 임의의 <b>입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것</b>
* MD5 : 1991년 R.rivest가 MD4 대체 위해
* TKIP : <b>WEP의 취약성을 보완한 데이터 보안 프로토콜</b>
* 침입 탐지 시스템
  * 오용 탐지 : 미리 입력해둔 공격패턴이 감지되면
  * 이상 탐지 : 평균적인 시스템의 상태를 기준으로
* AAA
  * 인가 Authorization
  * 과금 Accounting
* ISMS(정보보호 관리 체계) : <b>정보 자산을 안전하게 보호하기 위한 보호 절차와 대책 </b>
* LAND Attack : <b>패킷을 전송할 때 송수신 IP를 공격대상의 IP로하여 무한히 응답하게하는것</b>
* 세션 하이재킹 : <b>상호 인증 과정을 거친 후 접속해있는 서버와 클라이언트 사이의 세션 정보를 가로채는 공격기법</b>
* ARP 스푸핑 : ARP의 취약점을 이용, <b>자신의 물리적 주소(MAC)를 공격대상의 것으로 변조하여 데이터패킷을 가로채거나 방해하는 기법</b>
* 스니핑 : <b>네트워크의 중간에서 남의 패킷 정보를 도청</b>
* 워터링 홀 : <b>웹 사이트를 사전에 감염시켜 사이트에 방문했을 떄 악성코드에 감염되게 하는 공격</b>
* 랜섬웨어 : <b>내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램</b>
* 보안의 3대 요소 : 기밀성 무결성 가용성
  </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 10장 프로그래밍 언어 활용
### 중요도 <span style="color:red">A</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* 헝가리안 표기법 : <b>변수명 작성 시 자료형을 의미하는 문자를 포함하여 작성하는 방법</b>
* Python - 리스트 관련 주요 메소드

형식 | 내용 | 
---------|----------|
 pop(위치) | 리스트의 '위치'에 있는 값을 출력하고 해당 요소를 삭제함<br> [10, 11, 12].pop(1) -> 11출력 -> [10, 12] | 
 index(값) | 리스트에서 '값'이 저장된 요소의 위치를 반환<br> [10, 11, 12].index(12) ->2 | 
 count(값) | 리스트에서 '값'이 저장되어 있는 요소들의 개수를 반환<br> [1, 0, 1, 0, 0].count(0) -> 3 |
 extend(리스트) | 리스트의 끝에 새로운 '리스트'를 추가하여 확장<br> ['a', 'b'].extend(['c', 'd']) -> ['a', 'b', 'c', 'd'] 
reverse() | 순서를 역순으로 뒤집음<br> [1, 2, 3].reverse() -> [3, 2, 1]
sort() | 리스트를 정렬, 기본값 = 오름차순, reverse 이용하여 지정가능(True = 내림차순, False = 오름차순)<br> [2, 1, 3].sort() -> [1, 2, 3] / [2, 1, 3].sort(reverse = True) -> [3, 2, 1]
copy() | 리스트를 복사<br> a=[1, 2, 3], b = a.copy() -> a=[1, 2, 3] b=[1, 2, 3]

* C++에서 생성자 : <b>객체 변수를 생성하면서 초기화를 수행</b>

### 문제에서
* \n = 줄바꿈
* 자바 비트에서  ~ : not(부정연산후 원래값 알기위에 000000이되는 1한다음 부호비트에 따라 양수(0),음수(1)), ^ : nor(모두 같으면0 서로다르면 1), & : and, | : or
* 비트에서 음수일때 왼쪽 시프트(<)일경우 0 오른쪽시프트(>)일경우 1이들어옴 
  </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 11-1장 프로그래밍 언어 활용
### 중요도 <span style="color:red">A</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* UNIX - <b>AT&T 벨(Bell) 연구소, MIT, General Eletric이 공동 개발한 운영체제</b>

* Android - <b>구글 사에서 개발한 개방형 모바일 운영체제</b>

* 기억장치 관리 - 배치 전략
  <br> - <b>프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략</b>
  * 최초 적합(First Fit) : 빈 영역 중에서 첫번째 분할 영역에 배치 시키는 방법
  * 최적 적합(Best Fit) : 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
  * 최악 적합(Worst Fit) : 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

* 가상기억장치 구현 기법
  * 페이징 기법
  <br> - <b>프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 주기억장치의 영역에 적재시켜 실행하는 기법</b>
  * 세그먼테이션 기법
  <br> - <b>프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법</b>

* 페이지 교체 알고리즘
  <br> - <b>페이지 부재가 발생하면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법</b>
  <br> - 종류 : OPT, FIFO, LRU, LFU, NUR, SCR

* 스래싱 - <b>프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상</b>

* 스레드 - <b>시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위</b>

* 프로세스 상태 전이
  <br>- 제출 -> 접수 -> i) 준비 <-> 실행 -> 대기 -> 준비 -> 실행 -> 종료 <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii) 준비 <-> 실행 -> 종료
  <br> - 접수 <-> 디스크

* HRN
  <br> - <b>대기 시간과 서비스(실행) 시간을 이용하는 기법</b>
  <br> - <b>우선순위 계산식</b> = (대기시간 + 서비스시간) / 서비스시간

* UNIX/LINUX 기본 명령어
  * <b>cat</b> : 파일 내용을 화면에 표시
  * <b>cd</b> : 디렉터리의 위치를 변경
  * <b>chown</b> : 파일 소유자와 그룹을 변경
  * <b>cp</b> : 파일을 복사
  * <b>rm</b> : 파일을 삭제
  * <b>find</b> : 파일을 찾음
  * <b>kill</b> : PID(프로세스 고유 번호)를 이용하여 프로세스를 종료함
  * <b>fork</b><span style="color:red"><small> * 필기 20.8</small></span> : 새로운 프로세스를 생성
  * <b>is</b> : 현재 디렉터리의 파일 목록을 표시
  * <b>mkdir</b> : 디렉터리를 생성
  * <b>rmdir</b> : 디렉터리를 삭제
  * <b>mv</b> : 파일을 이동
  * <b>ps</b> : 현재 실행중인 프로세스를 표시
  * <b>pwd</b> : 현재 작업중인 디렉터리 경로를 화면에 표시
  * <b>who</b> : 현재 시스템에 접속해 있는 사용자 표시
  </div>
</details>

### 중요도 <span style="color:#0000ff">B</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* UNIX 시스템의 구성
  * <b>커널</b> : UNIX의 가장 핵심적인 부분, 프로세스 관리, 기억장치 관리 등의 기능 수행
  * <b>쉘</b> : 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기

* 기억장치 관리 - 반입 전략
  <br> - <b>반입 전략</b> : 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는  전략

* 주기억장치 할당 기법
  <br> - <b>프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지를 결정하는 기법</b>
  <br> - 연속 할당 기법 : 단일 분할 할당 기법, 다중 분할 할당 기법
  <br> - 분산 할당 기법 : 페이징 기법, 세그먼테이션 기법

* 가상기억장치 - <b>보조기억장치의 일부를 주기억장치처럼 사용하는 것</b>

* FIFO - <b>가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법</b>
  <br> - 이미 적재된 페이지는 해당 위치의 페이지 프레임을 사용한다

* Locality - <b>프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질</b>이 있다는 이론

* 워킹 셋  - <b>프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합</b>

* 프로세스  - <b>실행중인 프로그램</b>을 의미

* PCB - <b>운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳</b>

* 프로세스 상태 전이 관련 용어
  <br> - <b>Dispatch(디스패치)</b><span style="color:red"><small> * 필기 21.8</small></span> : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정 = 준비 -> 실행
  <br> - <b>Wake Up</b> : 입·출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정 : 대기 -> 준비
  <br> - <b>Spooling(스풀링)</b> : 접수 -> 디스크

* FCFS = FIFO
  <br> - 준비상태 큐에 도착한 순서에 따라 차례로 CPU 를 할당하는 기법
  <br> - ex) 작업 / 도착시간 / CPU = p1 0 13 / p2 3 35 / p3 8 2
  <br> - 평균 실행 시간 : (실행시간 총 합) / 프로세스 개수 = (13 + 35 + 8) / 3
  <br> - 평균 대기 시간 : 대기한시간의 총합 / 프로세스 개수 = 대기한시간 i = 0 / ii = 13 - 3(도착시간) = 10 / iii = 48 - 8(도착시간) = 40  i + ii + iii = 50 / 3
  <br> - 평균 반환 시간 : 반환 시간의 총합 / 프로세스 개수 = i = 13(p1cpu사용시간) / ii = 13(p1사용시간)+35(p2사용시간) - 3(p2도착시간) = 45 / iii = 13(p1사용시간)+35(p2사용시간)+2(p23사용시간) - 8(p3도착시간) = 42 최종 계산 식 == 13+45+42 / 3  = 최종 도착시간(cpu사용시간 첫번째부터 가산) - 도착시간 / 개수

* SJF
  <br> - <b>준비상태 큐에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU 할당하는 기법</b>
   프로세스번호 | 실행시간 |
  ---------|----------|
   P1 | 7 |
   P2 | 8 |
   P3 | 4 |
   P4 | 3 |

  풀이 <br>
   프로세스번호 | 실행시간 | 대기시간 | 반환시간 |
  ---------|----------| ----------------| ----------------|
   P4 | 3 | 0 | 3 |
   P3 | 4 | 3 | 7 |
   P1 | 7 | 7 | 14 |
   P2 | 8 | 14 | 22 |

  대기시간 : 바로 앞 프로세스의 반환시간
  <br> 반환시간 : 프로세스의 대기시간 + 실행시간
  <br> 평균 대기시간 = (0+3+7+14) / 4 = 6
  <br> 평균 반환시간 = (3+7+14+22) / 4 = 11.5

* 환경 변수
  <br> - <b>시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임</b>
  <br> * 환경변수 출력 명령어
  <br> - Windows : set
  <br> - UNIX, LINUX : set, env, printenv, setenv<span style="color:red"><small> * 필기 20.9</small></span>
  </div>
</details>

### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>

# 11-2장 응용 SW 기초 기술 활용 2
### 중요도 <span style="color:red">A</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* IP 주소
  * <b>인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소</b>
  * <b>IPv4</b>
    * 8비트씩 4부분, 총 32비트로 구성
  * <b>IPv6</b>
    * 16비트씩 8부분, 총 128비트

* OSI 참조 모델(7계층 : 물데네전 세표응)
  <br> - <b>ISO에서 제안한 통신 규약</b>
  * 물리 계층<span style="color:red"><small> * 필기 20.5</small></span>
  <br> - 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의
  * 데이터 링크 계층 계층<span style="color:red"><small> * 필기 21.10, 21.3, 20.8</small></span>
  <br> - 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당한다
  * 네트워크 계층<span style="color:red"><small> * 필기 21.10, 21.5</small></span>
  <br> - 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함
  * 전송 계층<span style="color:red"><small> * 필기 20.9, 20.5</small></span>
  <br> - 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템간에 투명한 데이터 전송을 가능하게 함
  * 세션 계층
  <br> - 송·수신 측 간의 관련성을 유지하고 대화 제어를 담당
  * 표현 계층<span style="color:red"><small> * 필기 21.10</small></span>
  <br> - 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층, 코드 변환, 데이터 암호화 등의 기능 수행
  * 응용 계층
  <br> - 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공함

* 프로토콜 : <b>데이터 교환을 원활하게 수행할 수 있도록 표준화 시켜 놓은 통신 규약</b>, 톰마릴의 '기술적 은어'라는 뜻

* 프로토콜의 기본 3요소(구의시) : <b>구문, 의미, 시간</b>

* 패킷 교환 방식
  * 가상 회선 방식 : 출발지와 목적지의 전송 경로를 미리 연결
  * 데이터그램 방식 : 비연결형 통신에서 주로 사용, 사전에 접속 절차 수행 X

* ICMP : IP와 조합하여 통신중에 발생하는 제어 메시지를 관리하는 역할

* ARP : 호스트의 IP 주소 -> 물리적 주소(MAC address)로 변환

* RARP : 물리적 주소 -> IP 주소로 변환

* 네트워크 관련 신기술
  * 메시 네트워크 : 차세대 이동통신, 홈네트워킹 등 특수 목적을 위한 새로운 방식의 네트워크 기술
  * 피코넷 : 블루투스 기술이나 UWB통신 기술
  * 애드 혹 네트워크 : 재난 현장과 같이 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크
  * 파장 분할 다중화(WDM) : 광섬유를 이용한 통신기술의 하나로, 파장이 서로 다른 복수의 신호를
  * 소프트웨어 정의 데이터센터(SDDC) : 데이터 센터의 모든 자원을 가상화하여 인력의 개이없이 소프트웨어 조작만으로 관리 및 제어되는 데이터 센터를 의미
  * 개방형 링크드 데이터(LOD) : 웹상에 존재하는 데이터를 개별 URI로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형

* NAT(네트워크 주소 변환) : 한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소를 할당 및 연결하는 기능

* IGP : 라우팅에 사용되는 프로토콜
  * RIP : 최단 경로 탐색에 Bellman-Ford 알고리즘 사용
  * OSPF : 최단 경로 탐색에 Dijkstra 알고리즘 사용

* SW 관련 신기술
  * 블록체인 : P2P 네트워크를 이용하여 온라인 금융거래 정보를 온라인 네트워크 참여자의 디지털 장비에 분산 저장하는 기술
  * 매시업 : 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스등을 만드는 기술
  * 서비스 지향 아키텍처 : 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 아키텍처
  * 디지털 트윈 : 현실 속의 사물을 소프트웨어로 가상화한 모델

* RAID(0~6)
  * RAID 0<span style="color:red"><small> * 필기 22.5</small></span>
  <br> - 스트라이핑이라고 불림
  <br> - 하나의 디스크만 손상되어도 전체 데이터가 파손됨
  * RAID 1
  <br> - 미러링이라고 불림
  <br> - 같은 데이터를 다른 디스크에 동일하게 복사하는 방식
  * RAID 2~4
  <br> - 오류 정정 부호를 하나의 디스크에 저장
  <br> - 하나의 디스크가 손상되어도 정상 가동 가능, 최소 3개의 디스크 필요
  * RAID 5
  <br> - 오류 정정 부호를 여러 디스크에 저장
  <br> - 하나의 디스크가 손상되어도 정상 가동 가능, 최소 3개의 디스크 필요
  * RAID 6
  <br> - RAID 5와 원리는 같으나 오류 정정 부호 2개를 저장하는 방식
  <br> - 두개의 디스크가 손상되어도 정상 가동이 가능, 최소 4개의 디스크 필요

* DB 관련 신기술
  * 하둡 : 오픈소스를 기반으로 한 분산 컴퓨팅 플랫폼
  * 맵리듀스 : 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델
  * 데이터 마이닝 : 데이터에 내재된 변수 사이의 상호관계를 규명하여 패턴을 찾아내는 기법

* REDO : 데이터베이스가 비정상적으로 종료되었을때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작과 완료에 대한 기록이 있는 트랜잭션들의 작업을 재작업한다

* UNDO : 데이터베이스가 비정상적으로 종료되었을때 시작은 있지만 완료 기록은 없는 트랜잭션들이 작업한 변경 내용들을 모두 취소한다

* 즉각 갱신 기법 : 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법

* 로킹 : 병행제어 기법 중 하나로 접근한 데이터에 대한 연산을 모두 마칠 때까지 추가적인 접근을 제한하는 기법
  </div>
</details>





### 중요도 <span style="color:#0000ff">B</span><br>
<details>
  <summary></summary>
  <div markdown="1">
    
    

* IPv6의 주소 체계 세 가지
  * 유니캐스트
  * 멀티캐스트
  * 애니캐스트

* 네트워크 관련 장비
  * 라우터 : 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택하는 기능이 추가된 장치

* TCP : 양방향 가상회선 제공

* UDP : 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공하는 프로토콜
  </div>
</details>




### 중요도 <span style="color:green">C</span><br>

<details>
  <summary></summary>
  <div markdown="1">
    
  </div>
</details>